//#1 Two Sum
//throw exception if no result !!

class Solution {
    public int[] twoSum(int[] nums, int target) {
        
        HashMap<Integer,Integer> hs = new HashMap<Integer,Integer>();
        
        for(int i = 0;i<nums.length;++i){
            hs.put(nums[i], i);
        }
        
        for(int i = 0;i<nums.length;++i){
            if(hs.containsKey(target - nums[i]) && hs.get(target - nums[i]) != i) {
                return new int[] {i, hs.get(target - nums[i])};
            }
        }     
        throw new IllegalArgumentException("No two sum solution");
    }
}

/*
# 2. Add Two Numbers
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example:

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
*/
//Notice to handle carry after the while loop.
//Notice to check both l1 and l2 in each loop.
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if(!l1){
            return l2;
        } else if(!l2){
            return l1;
        }
        
        ListNode dummyHead(0);
        ListNode* head = &dummyHead;
        int carry = 0;
        while(l1 || l2){
            
            int v1 = l1? l1->val : 0;
            int v2 = l2? l2->val : 0;
            int curRes = carry + v1 + v2;
            carry = curRes/10;
            ListNode* newNode = new ListNode(curRes%10);
            head->next = newNode;
            head = head->next;
            if(l1){
                l1 = l1->next;
            }
            if(l2){
                l2 = l2->next;
            }            
        }
        if(carry >= 1){
            ListNode* newNode = new ListNode(carry);
            head->next = newNode;
        }
        
        return dummyHead.next;
    }

//#34 Find First and Last Position of Element in Sorted Array
//update mid in while !!

class Solution {
    public int[] searchRange(int[] nums, int target) {
        
        int start = 0;
        int end = nums.length - 1;
        
        int first = -1;
        int last = -1;
        
        if(nums.length < 1){
            return new int[] {first,last}; 
        }
        
        //first position
        while (start < end - 1) {
            int mid = (end - start)/2 + start;
            if(nums[mid] > target){
                end = mid - 1;
                //BinarySearch(nums, start, mid - 1, target);
            } else if (nums[mid] < target) {
                start = mid + 1;
                //BinarySearch(nums, mid + 1, end, target);
            } else {
                end = mid;
            }
        }       
        
        if (nums[start] == target) {
            first = start;
        } else if (nums[end] == target){
            first = end;
        }
        
        //find last
        start = 0;
        end = nums.length - 1;
        while (start < end - 1) {
            int mid = (end - start)/2 + start;
            if(nums[mid] > target){
                end = mid - 1;
                //BinarySearch(nums, start, mid - 1, target);
            } else if (nums[mid] < target) {
                start = mid + 1;
                //BinarySearch(nums, mid + 1, end, target);
            } else {
                start = mid;
            }
        }       
        
        if (nums[end] == target) {
            last = end;
        } else if (nums[start] == target){
            last = start;
        }         
        return new int[] {first,last};     
    }
}

//#83 Remove Duplicates from Sorted List    
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
 
 //Do not forget to move cur pointer to next one only when no node is removed 
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        
        if(head == NULL || head->next == NULL){
            return head;
        }
        
        ListNode dummyHead(0);
        ListNode *dHead = &dummyHead;
        dummyHead.next = head;
        
        while(head->next){
            if(head->val == head->next->val){
                head->next = head->next->next;
            } else {
                head = head->next;
            }
            
        }
        return dummyHead.next;
    }
};

#3. Longest Substring Without Repeating Characters
//Imagine maintaining a sliding window. Update left border when find a repeat char.
//Method1: use vector
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //map<char,int> dict;
        vector<int> m(256, -1);
        //int head = 0;
        int tail = -1;
        int result = 0;
        
        for(int i = 0; i<s.size();++i){
             
            /*if(m[s[i]] != -1){
                tail = m[s[i]];
            }*/
            //Tail should not move if the last dup index is less than current tail. e.g. "abba" tail should not back to the first 'a'
            tail = max(tail,m[s[i]]);
            m[s[i]] = i;  
            result = max(result, i - tail);
        }
        return result;
    }
};

//method2: use map
int lengthOfLongestSubstring(string s) {
	int result = 0;
	int tail = -1;
	unordered_map<char, int> charMap;

	for (int i = 0; i < s.size(); ++i) {
		if (charMap.count(s[i])) {
			tail = max(tail, charMap[s[i]]);
		}
		result = max(result, i - tail);
		charMap[s[i]] = i;
	}
	return result;
}

/*
#4 Median of Two Sorted Arrays

There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

You may assume nums1 and nums2 cannot be both empty.

Example 1:

nums1 = [1, 3]
nums2 = [2]

The median is 2.0
Example 2:

nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
*/

double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
	int len1 = nums1.size();
	int len2 = nums2.size();

	//trick here. if len1 + len2 is uneven, then (len1 + len2 + 1) / 2 == (len1 + len2 + 2) / 2)
	return (findKthElement(nums1, nums2, (len1 + len2 + 1) / 2) + findKthElement(nums1, nums2, (len1 + len2 + 2) / 2)) / 2;
}

//If we want to find the Kth smallest element in two sorted asc arrays. we can use binary search to cut k/2 elements from one array in each recursion.
//Because if array1[k/2] < array2[k/2], then we can abandon k/2 elements in array1.
//Notice two recursion exits !! 
double findKthElement(vector<int>& nums1, vector<int>& nums2, int k) {

	int len1 = nums1.size();
	int len2 = nums2.size();

	//Handle some corner cases
	if (k > len1 + len2) {
		return -1;
	}
	if (len1 > len2) {
		return findKthElement(nums2, nums1, k);
	}

	//Recursion exit
	if (len1 == 0) {
		return nums2[k - 1];
	}
	if (k == 1) {
		return _Min_value(nums1[0], nums2[0]);
	}

	int binaryIndex1 = _Min_value(k / 2, len1);
	int binaryIndex2 = k - binaryIndex1;

	if (nums1[binaryIndex1 - 1] > nums2[binaryIndex2 - 1]) {
		vector<int> newVec(nums2.begin() + binaryIndex2, nums2.end());
		return findKthElement(nums1, newVec, k - binaryIndex2);
	}
	else if (nums1[binaryIndex1 - 1] < nums2[binaryIndex2 - 1]) {
		vector<int> newVec(nums1.begin() + binaryIndex1, nums1.end());
		return findKthElement(newVec, nums2, k - binaryIndex1);
	}
	else {
		return nums1[binaryIndex1 - 1];
	}
}

/*
#5 Longest Palindromic Substring
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
Example 2:

Input: "cbbd"
Output: "bb"
*/
//Handle both uneven and even cases.
string longestPalindrome(string s) {

	int maxLength = 1;
	int center = 0;

	
	for (int i = 0; i< s.size();++i) {
		//int center = i;
		//Check for uneven case, notice r and maxlen are initialed as 1
		int maxlen = 1;
		int r = 1;

		//Notice >=0 here
		while (i - r >= 0 && i + r < s.size() && s[i - r] == s[i + r]) {
			maxlen += 2;
			r++;
		}
		if (maxlen > maxLength) {
			maxLength = maxlen;
			center = i;
		}

		//Check for even case, notice maxlen and r are initialed as 0
		maxlen = 0;
		r = 0;
		while (i - r >= 0 && i + 1 + r < s.size() && s[i - r] == s[i + 1 + r]) {
			maxlen += 2;
			r++;
		}
		if (maxlen > maxLength) {
			maxLength = maxlen;
			center = i;
		}
	}

	if (maxLength % 2 == 0) {
		return s.substr(center - maxLength / 2 + 1, maxLength);
	}
	else {
		return s.substr(center - (maxLength - 1) / 2, maxLength);
	}
}

/*
#6 ZigZag Conversion

The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);
Example 1:

Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
Example 2:

Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I
*/

string convert(string s, int numRows) {

	//Notice handle special cases !
	if (numRows <= 1) {
		return s;
	}

	string result = "";

	//Convert it into meth problem.
	for (int i = 0; i<numRows; ++i) {
		for (int j = i; j<s.size();j += 2 * numRows - 2) {
			result += s[j];
			if (i != 0 && i != numRows - 1 && j + 2 * numRows - 2 * (i + 1) < s.size()) {
				result += s[j + 2 * numRows - 2 * (i + 1)];
			}
		}
	}
	return result;
}
/*
# 7. Reverse Integer
Given a 32-bit signed integer, reverse digits of an integer.

Example 1:

Input: 123
Output: 321
Example 2:

Input: -123
Output: -321
Example 3:

Input: 120
Output: 21
Note:
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range:[MIN,MAX].For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
*/
//Notice to check overflow
//result = result*10 + x%10; Notice condition of while loop is x!=0
int reverse(int x) {
        
        int result = 0;
        
        while(x != 0){
            
            if(result > INT_MAX/10 || (result == INT_MAX / 10 && x%10 > 7)){
                return 0;
            }
            if(result < INT_MIN/10 || (result == INT_MIN / 10 && x%10 < -8)){
                return 0;
            }
            
            result = result*10 + x%10;
            x /= 10;
        }       
        return result;
    }

/*
# 8. String to Integer (atoi)
Implement atoi which converts a string to an integer.

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned.

Note:

Only the space character ' ' is considered as whitespace character.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range:. If the numerical value is out of the range of representable values, INT_MAX or INT_MIN is returned.
Example 1:

Input: "42"
Output: 42
Example 2:

Input: "   -42"
Output: -42
Explanation: The first non-whitespace character is '-', which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.
Example 3:

Input: "4193 with words"
Output: 4193
Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.
Example 4:

Input: "words and 987"
Output: 0
Explanation: The first non-whitespace character is 'w', which is not a numerical 
             digit or a +/- sign. Therefore no valid conversion could be performed.
Example 5:

Input: "-91283472332"
Output: -2147483648
Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.
             Therefore INT_MIN is returned.
*/
//Notice single '', not ""
int myAtoi(string str) {
	if (str.empty()) {
		return 0;
	}

	int sign = 1;
	int result = 0;
	int length = str.size();
	int i = 0;
	while (i < length && str[i] == ' ') {
		++i;
	}

	if (str[i] == '+') {
		sign = 1;
		i++;
	}
	else if (str[i] == '-') {
		sign = -1;
		i++;
	}
	else if (str[i] > '9' || str[i] < '0') {
		return 0;
	}

	while (i < length && (str[i] >= '0' && str[i] <= '9')) {
		/*if(str[i] > '9' or str[i] < '0'){
		return 0;
		}*/
		if (result * sign > INT_MAX / 10 || (result * sign == INT_MAX / 10 && str[i] - '0'> 7)) {
			return INT_MAX;
		}
		else if (result * sign < INT_MIN / 10 || (result * sign == INT_MIN / 10 && str[i] - '0' > 8)) {
			return INT_MIN;
		}
		result = result * 10 + (str[i] - '0');
		i++;
	}
	return result * sign;
}

/*
#9. Palindrome Number

Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

Example 1:

Input: 121
Output: true
Example 2:

Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
Follow up:

Coud you solve it without converting the integer to a string?
*/

//Check if its reverse num equals to original num
//Another method: convert it into string.
//Another method; Check if head equals to tail step by step 
class Solution {
public:
    bool isPalindrome(int x) {
        
        if(x < 0){
            return false;
        }
        if (x == ReverseInt(x)){
            return true;
        } else {
            return false;
        }
    }
    
    int ReverseInt(int x){
        
        int result = 0;
        while(x != 0){
            if(result > INT_MAX/10 || (result == INT_MAX/10 && x%10 > 7)) {
                return -1;
            }
            result = result * 10 + x%10;
            x /= 10;
        }
        return result;
    }
};

/*
#11. Container With Most Water
Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container and n is at least 2.
*/
//Left&right pointer.Notice the area is decided by the min side. So just move the pointer on min side.

int maxArea(vector<int>& height) {
        
        if(height.size() <= 1){
            return 0;
        }
        
        int left = 0;
        int right = height.size() - 1;
        int result = 0;
        
        while(left != right){
            
            if(height[left] < height[right]){
                result = max(result, height[left] * (right - left));
                ++left;
            } else {
                result = max(result, height[right] * (right - left));
                --right;
            }
        }
        return result;
    }
    
/*
# 12. Integer to Roman
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.
*/
//Can be improved. 5-8 can be merged in a for loop.
 string intToRoman(int num) {
        
        string result = "";
        int thousand = (num/1000)%10;
        int hundred = (num/100)%10;
        int ten = (num/10)%10;
        int one = num%10;
        
        if (thousand > 0){
            for(int i = 0; i<thousand;++i){
                result.append("M");
            }
        }
        if(hundred > 0){
            if (hundred > 0 && hundred <= 3){
               for(int i = 0; i<hundred;++i){
                result.append("C");
                } 
            } else if (hundred == 4) {
                result.append("CD");
            } else if (hundred == 5) {
                result.append("D");
            } else if (hundred == 6) {
                result.append("DC");
            } else if (hundred == 7) {
                result.append("DCC");
            } else if (hundred == 8) {
                result.append("DCCC");
            } else if (hundred == 9) {
                result.append("CM");
            }
        }
        if (ten > 0) {
            if (ten > 0 && ten <= 3){
               for(int i = 0; i<ten;++i){
                result.append("X");
                } 
            } else if (ten == 4) {
                result.append("XL");
            } else if (ten == 5) {
                result.append("L");
            } else if (ten == 6) {
                result.append("LX");
            } else if (ten == 7) {
                result.append("LXX");
            } else if (ten == 8) {
                result.append("LXXX");
            } else if (ten == 9) {
                result.append("XC");
            }
        }
        if (one > 0){
            if (one > 0 && one <= 3){
               for(int i = 0; i<one;++i){
                result.append("I");
                } 
            } else if (one == 4) {
                result.append("IV");
            } else if (one == 5) {
                result.append("V");
            } else if (one == 6) {
                result.append("VI");
            } else if (one == 7) {
                result.append("VII");
            } else if (one == 8) {
                result.append("VIII");
            } else if (one == 9) {
                result.append("IX");
            }
        }
        return result;
    }
//Brief version: use arrays and Classify cases into 0-3,4,5-8,9
string intToRoman(int num) {

	vector<char> charMap = { 'I','V','X','L','C','D','M' };
	vector<int> intMap = { 1,5,10,50,100,500,1000 };
	string result;
	for (int i = 6; i >= 0; i -= 2) {
		int bit = num / intMap[i];
		if (bit < 4) {
			for (int j = 0; j < bit; ++j) {
				result += charMap[i];
			}
		}
		else if (bit == 4) {
			result += charMap[i];
			result += charMap[i + 1];
		}
		else if (bit > 4 && bit < 9) {
			result += charMap[i + 1];
			for (int j = 0; j < bit - 5; ++j) {
				result += charMap[i];
			}
		}
		else {
			result += charMap[i];
			result += charMap[i + 2];
		}
		num %= intMap[i];
	}
	return result;
}
    
/*
13. Roman to Integer
*/
//Just add value bit by bit. Only notice 4 and 9 cases that need to minus firstly. 
int romanToInt(string s) {
        int result = 0;
        unordered_map<char,int> RToInt= {{'M', 1000},{'D', 500},{'C', 100},{'L',50},{'X',10},{'V',5},{'I',1}};
        
        for(int i = 0; i < s.size(); ++i){
        	//handle 4 and 9 cases here.
            if(i+1 < s.size() && RToInt[s[i]] < RToInt[s[i+1]]){
                result -= RToInt[s[i]];
            } else {
                result += RToInt[s[i]];
            }
        }
        return result;
 }
 
/*
# 14. Longest Common Prefix
*/

//Just check char by char. Notice return condition is strs[i][j] != cur || j >= strs[i].size()
string longestCommonPrefix(vector<string>& strs) {
	if(strs.empty()) {
        return "";
    }
        
    string result = "";
        
    for(int j = 0; j< strs[0].size();++j){
        char cur = strs[0][j];
        for(int i = 1; i < strs.size(); ++i){
        //Notice to check length range here !!!
            if(strs[i][j] != cur || j >= strs[i].size()){
                return result; 
            }
        }
        result += cur;
    }
    return result;	
} 

/*
# 15. 3Sum

Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

The solution set must not contain duplicate triplets.

Example:

Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
*/

//Sort the array;Fix one number firstly, then use 2 pointers to find "twoSum"
//Notice to skip dups AFTER one calculation.
//Do not forget to move pointers after get a solution
vector<vector<int>> threeSum(vector<int>& nums) {
	
	//Handle corner case
	if (nums.size() < 3) {
		return {};
	}
	
	//Sort to make the problem easier
	sort(nums.begin(), nums.end());
	vector<vector<int>> result;
	
	//Notice limit of i here !!
	for (int i = 0; i< nums.size() - 2;++i) {
		
		//Improve eff
		if (nums[i] > 0) {
			return result;
		}
		
		//Prevent dup result, notice continue !!! not break !!!
		if (i != 0 && nums[i - 1] == nums[i]) {
			continue;
		}
		
		//Two pointers to deal with "twoSum"
		int twoSum = 0 - nums[i];
		int start = i + 1;
		int end = nums.size() - 1;
		while (start < end) {
			if (nums[start] + nums[end] == twoSum) {
				result.push_back({ nums[i], nums[start], nums[end] });
				
				//Prevent dup here !!!
				++start;
				while (nums[start] == nums[start - 1] && start < end) {
					++start;
				}
				--end;
				while (nums[end] == nums[end + 1] && start < end) {
					--end;
				}
			}
			else if (nums[start] + nums[end] > twoSum) {
				--end;
			}
			else {
				++start;
			}
		}
	}
	return result;
}
/*
# 16. 3Sum Closest
Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

Example:

Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
*/
//No dup assumption makes it much easier. Just remember to update result. And notice initial value of result !!!!! 
int threeSumClosest(vector<int>& nums, int target) {

	int result = INT_MAX;
	if (nums.size() < 3) {
		return result;
	}

	sort(nums.begin(), nums.end());
	//notice initial value of result !!!!!
	result = nums[0] + nums[1] + nums[2];
	for (int i = 0; i < nums.size() - 2; ++i) {

		int twoSum = target - nums[i];
		int start = i + 1;
		int end = nums.size() - 1;

		while (start < end) {
			if (nums[start] + nums[end] == twoSum) {
				return target;
			}
			else if (nums[start] + nums[end] < twoSum) {
				if (abs(result - target) > abs(nums[start] + nums[end] - twoSum)) {
					result = nums[start] + nums[end] + nums[i];
				}
				++start;
			}
			else {
				if (abs(result - target) > abs(nums[start] + nums[end] - twoSum)) {
					result = nums[start] + nums[end] + nums[i];
				}
				--end;
			}
		}
	}
	return result;
}

/*
# 17. Letter Combinations of a Phone Number
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example:

Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
Note:

Although the above answer is in lexicographical order, your answer could be in any order you want.
*/

//remove one digit after each recur. 
vector<string> letterCombinations(string digits) {
	if (digits.empty()) {
		return {};
	}

	vector<string> result;
	string curCom;
	string keyboard[] = { "","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz" };
	ComRec(keyboard, digits, curCom, result);
	return result;
}

void ComRec(string keys[], string digits, string cur, vector<string>& result) {
	if (digits.empty()) {
		result.push_back(cur);
		return;
	}

	for (int i = 0; i < keys[digits[0] - '0'].size(); ++i) {
		cur.push_back(keys[digits[0] - '0'][i]);
		ComRec(keys, digits.substr(1), cur, result);
		cur.pop_back();
	}
}

//Second version
/*vector<string> letterCombinations(string digits) {

	if (digits.size() == 0) {
		return {};
	}
	int length = digits.size();
	//vector<vector<string>> keyboard = { {},{},{ "a","b","c" },{ "d","e","f" },{"g","h","i"},{ "j","k","l" },{ "m","n","o" },{ "p","q","r","s" },{"t","u","v","w" },{"x","y","z"} };
	//vector<vector<string>> keyboard = {{ "a","b","c" },{ "d","e","f" },{ "g","h","i" },{ "j","k","l" },{ "m","n","o" },{ "p","q","r","s" },{ "t","u","v","w" },{ "x","y","z" } };
	string keyboard[] = { "","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz" };
	string* inputKeys = new string[digits.size()];
	for (int i = 0; i < digits.size();i++) {
		int num = digits[i] - '0';
		inputKeys[i] = keyboard[num];
	}

	vector<string> result = {};
	string currentCom;
	getCombinations(inputKeys, result, currentCom, length);
	return result;
}

void getCombinations(string inputKeys[], vector<string> &res, string &cur, int length) {

	if (cur.size() == length) {
		res.push_back(cur);
		return;
	}

	//if(start > 1) return;

	for (int j = 0;j<inputKeys[cur.size()].size();j++) {
		cur += inputKeys[cur.size()][j];
		getCombinations(inputKeys, res, cur, length);
		cur.pop_back();
	}
}*/

/*
# 18. 4Sum
Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:

The solution set must not contain duplicate quadruplets.

Example:

Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
*/
vector<vector<int>> fourSum(vector<int>& nums, int target) {
	if (nums.size() < 4) {
		return {};
	}

	sort(nums.begin(), nums.end());
	vector<vector<int>> result;
	for (int i = 0; i < nums.size() - 3; ++i) {
		
		//MUST NOT CONTAIN tHIS !!!
		/*if (nums[i] > target) {
		return result;
		}*/

		if (i != 0 && nums[i - 1] == nums[i]) {
			continue;
		}

		int threeSumTar = target - nums[i];
		vector<int> threeSumVec(nums.begin() + i + 1, nums.end());
		threeSum(threeSumVec, threeSumTar, result, nums[i]);
		//vector<vector<int>> threeSumRes = threeSum(vector(nums.begin() + i + 1, nums.end()), int threeSum);
		//result.push_back(threeSumRes[][]);
	}
	return result;
}

void threeSum(vector<int>& nums, int target, vector<vector<int>>& result, int addend) {

	//Handle corner case
	if (nums.size() < 3) {
		return;
	}

	//Sort to make the problem easier
	sort(nums.begin(), nums.end());
	//vector<vector<int>> result;

	//Notice limit of i here !!
	for (int i = 0; i< nums.size() - 2;++i) {
		
		//MUST NOT CONTAIN tHIS !!!
		//Improve eff
		/*if (nums[i] > target) {
		return;
		}*/

		//Prevent dup result, notice continue !!! not break !!!
		if (i != 0 && nums[i - 1] == nums[i]) {
			continue;
		}

		//Two pointers to deal with "twoSum"
		int twoSum = target - nums[i];
		int start = i + 1;
		int end = nums.size() - 1;
		while (start < end) {
			if (nums[start] + nums[end] == twoSum) {
				result.push_back({ nums[i], nums[start], nums[end], addend });

				//Prevent dup here !!!
				++start;
				while (nums[start] == nums[start - 1] && start < end) {
					++start;
				}
				--end;
				while (nums[end] == nums[end + 1] && start < end) {
					--end;
				}
			}
			else if (nums[start] + nums[end] > twoSum) {
				--end;
			}
			else {
				++start;
			}
		}
	}
	//return result;
}

/*
# 19. Remove Nth Node From End of List
Given a linked list, remove the n-th node from the end of list and return its head.

Example:

Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.
Note:

Given n will always be valid.

Follow up:

Could you do this in one pass?
*/

//Create another pointer "right" that initially locates at head.
//Move it n steps and check if it reaches the end, if so return head-next.
//If not, move the "right" and head pointers together until "right" reaches the end.
//At the moment head should locate at the n-1th node.
ListNode* removeNthFromEnd(ListNode* head, int n) {

	if (n <= 0 || !head) {
		return head;
	}

	ListNode dummyHead(-1);
	dummyHead.next = head;
	ListNode* right = head;
	//head = &dummyHead;

	for (int i = 0; i < n; ++i) {
		right = right->next;
	}

	if (!right) {
		return head->next;
	}

	while (right->next) {
		head = head->next;
		right = right->next;
	}
	head->next = head->next->next;

	return dummyHead.next;
}

/*
# 20. Valid Parentheses
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: "()"
Output: true
Example 2:

Input: "()[]{}"
Output: true
Example 3:

Input: "(]"
Output: false
Example 4:

Input: "([)]"
Output: false
Example 5:

Input: "{[]}"
Output: true
*/

//Use stack to match. Notice to check if sta if empty in progress and at the end.

bool isValid(string s) {

	if (s.empty()) {
		return true;
	}
	stack<char> sta;

	for (int i = 0; i < s.size(); ++i) {
		if (s[i] == '(' || s[i] == '[' || s[i] == '{') {
			sta.push(s[i]);
		}
		else if (sta.empty()) {
			return false;
		}
		else if (s[i] == ')' && sta.top() == '(') {
			sta.pop();
		}
		else if (s[i] == ']' && sta.top() == '[') {
			sta.pop();
		}
		else if (s[i] == '}' && sta.top() == '{') {
			sta.pop();
		}
		else if (s[i] == ')' || s[i] == ']' || s[i] == '}') {
			return false;
		}
	}
	if (!sta.empty()) {
		return false;
	}
	else {
		return true;
	}
}

/*
# 21. Merge Two Sorted Lists
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Example:

Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
*/
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
	if (!l1) {
		return l2;
	}
	else if (!l2) {
		return l1;
	}

	ListNode dummyHead(-1);
	ListNode* head = &dummyHead;
	
	//Notice it is && not || !!!
	while (l1 && l2) {
		if (l1->val < l2->val) {
			head->next = l1;
			l1 = l1->next;
		}
		else {
			head->next = l2;
			l2 = l2->next;
		}
		head = head->next;
	}

	if (l1) {
		head->next = l1;
	}
	else {
		head->next = l2;
	}
	return dummyHead.next;
}

/*
#22. Generate Parentheses
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
*/

//Notice if there is any ( or ) left we can keep rec, but if there are more ( left than ), then it is a invalid com. 
vector<string> generateParenthesis(int n) {
        vector<string> result;
        RecursiveGenerate(n,n,result,"");
        return result;
    }
    
    void RecursiveGenerate(int leftNum, int rightNum, vector<string>& result, string cur){
        if(leftNum > rightNum){
            return;
        } else if (leftNum == 0 && rightNum == 0){
            result.push_back(cur);
        }
        
        if(leftNum > 0){
            cur.push_back('(');
            RecursiveGenerate(leftNum - 1, rightNum, result, cur);
            cur.pop_back();
        }
        if(rightNum > 0){
            cur.push_back(')');
            RecursiveGenerate(leftNum, rightNum - 1, result, cur);
            cur.pop_back();
        }
        
    }

/*
# 23. Merge k Sorted Lists
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
*/

//Notice edge cases !!
//Use merge and sort: take use of mergeTwoSortedLists function.
ListNode* mergeKLists(vector<ListNode*>& lists) {
	if (lists.empty()) {
		return NULL;
	}
	return mergeAndInsert(lists, 0, lists.size() - 1);
}

ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
	if (!list1) {
		return list2;
	}
	else if (!list2) {
		return list1;
	}

	ListNode dummyHead(0);
	ListNode* head = &dummyHead;

	while (list1 && list2) {
		if (list1->val < list2->val) {
			head->next = list1;
			list1 = list1->next;
		}
		else {
			head->next = list2;
			list2 = list2->next;
		}
		head = head->next;
	}
	if (list1) {
		head->next = list1;
	}
	else if (list2) {
		head->next = list2;
	}

	return dummyHead.next;
}

ListNode* mergeAndInsert(vector<ListNode*>& lists, int start, int end) {
	if (start == end) {
		return lists[start];
	}

	int mid = (end - start) / 2 + start;
	ListNode* l1 = mergeAndInsert(lists, start, mid);
	ListNode* l2 = mergeAndInsert(lists, mid + 1, end);
	return mergeTwoLists(l1, l2);
}

/*
#24. Swap Nodes in Pairs
Given a linked list, swap every two adjacent nodes and return its head.

Example:

Given 1->2->3->4, you should return the list as 2->1->4->3.
Note:

Your algorithm should use only constant extra space.
You may not modify the values in the list's nodes, only nodes itself may be changed.
*/

ListNode* swapPairs(ListNode* head) {

	if (!head || !head->next) {
		return head;
	}

	ListNode dummyHead(-1);
	dummyHead.next = head;
	head = &dummyHead;

	while (head->next && head->next->next) {
		ListNode* tmp = head->next->next;
		head->next->next = tmp->next;
		//NOTICE !!! must tmp->next, not head->next->next->next, because head->next->next was changed in last line;
		tmp->next = head->next;
		head->next = tmp;
		head = head->next->next;
	}

	return dummyHead.next;
}    

/*
#25. Reverse Nodes in k-Group
Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.

Example:

Given this linked list: 1->2->3->4->5

For k = 2, you should return: 2->1->4->3->5

For k = 3, you should return: 3->2->1->4->5

Note:

Only constant extra memory is allowed.
You may not alter the values in the list's nodes, only nodes itself may be changed.
*/

//A newTail and a pre. Notice where to update pre and new newTail
ListNode* reverseKGroup(ListNode* head, int k) {

	if (!head || !head->next) {
		return head;
	}

	ListNode dummyHead(-1);
	dummyHead.next = head;
	ListNode* newTail = head;
	ListNode* pre = &dummyHead;
	//ListNode* newPre = pre;

	while (KthNodeExists(pre, k)) {
	//Notice the limit is k-1 !!!!!!
		for (int i = 0; i < k - 1; ++i) {
			ListNode* tmp = newTail->next;
			newTail->next = tmp->next;
			tmp->next = pre->next;
			pre->next = tmp;
		}
		
		//New pre and new newTail
		pre = newTail;
		newTail = newTail->next;
	}
	return dummyHead.next;
}
bool KthNodeExists(ListNode* head, int k) {

	if (!head) {
		return false;
	}
	ListNode* dummy = head;
	for (int i = 0; i < k; ++i) {
		if (!dummy->next) {
			return false;
		}
		dummy = dummy->next;
	}
	return true;
}

/*
#26. Remove Duplicates from Sorted Array
Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
*/
//Or two pointers ??
//Notice how to use erase; Notice if any dup is erased, i remains(do not ++i)
int removeDuplicates(vector<int>& nums) {

	if (nums.empty()) {
		return 0;
	}
	else if (nums.size() == 1) {
		return 1;
	}

	for (int i = 1; i<nums.size(); ) {
		if (nums[i] == nums[i - 1]) {
			nums.erase(nums.begin() + i);
		}
		else {
			++i;
		}
	}
	return nums.size();
}

/*
#27. Remove Element

Given an array nums and a value val, remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Example 1:

Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn't matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums, val);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
*/
//Or two pointers ??
//Notice how to use erase; Notice if any dup is erased, i remains(do not ++i)
int removeElement(vector<int>& nums, int val) {
	if (nums.empty()) {
		return 0;
	}

	for (int i = 0; i < nums.size();) {
		if (nums[i] == val) {
			nums.erase(nums.begin() + i);
		}
		else {
			++i;
		}
	}
	return nums.size();
}

/*
# 28. Implement strStr()
Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = "hello", needle = "ll"
Output: 2
Example 2:

Input: haystack = "aaaaa", needle = "bba"
Output: -1
Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().
*/
//Compare the first letter and then the whole needle
//Notice how to use substr. Notice to handle edge cases.
int strStr(string haystack, string needle) {

	if (needle.empty()) {
		return 0;
	}
	else if (haystack.size() < needle.size()) {
		return -1;
	}

	int hSize = haystack.size();
	int nSize = needle.size();

	for (int i = 0; i < hSize - nSize + 1; ++i) {
		if (haystack[i] == needle[0]) {
			if (needle == haystack.substr(i, nSize)) {
				return i;
			}
		}
	}
	return -1;
}

/*
# 29. Divide Two Integers
Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero.

Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Example 2:

Input: dividend = 7, divisor = -3
Output: -2
Note:

Both dividend and divisor will be 32-bit signed integers.
The divisor will never be 0.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range:. For the purpose of this problem, assume that your function returns  when the division result overflows.
*/
//Use bit operation
//Notice edge case and how to handle sign
//Use long long and labs !!
int divide(int dividend, int divisor) {
	if (!divisor || (dividend == INT_MIN && divisor == -1)) {
		return INT_MAX;
	}

	int sign = ((dividend < 0) ^ (divisor < 0)) ? -1 : 1;
	int result = 0;
	long long m = labs(dividend);
	long long n = labs(divisor);

	while (m >= n) {
		long long tmp = n;
		long long inc = 1;
		while (m >= (tmp << 1)) {
			inc <<= 1;
			tmp <<= 1;
		}
		result += inc;
		m -= tmp;
	}
	return sign == 1 ? result : -result;
}

/*
# 30. Substring with Concatenation of All Words
You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.

Example 1:

Input:
  s = "barfoothefoobarman",
  words = ["foo","bar"]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively.
The output order does not matter, returning [9,0] is fine too.
Example 2:

Input:
  s = "wordgoodgoodgoodbestword",
  words = ["word","good","best","word"]
Output: []
*/
//Method1:
//Two maps, one for checking, another one for counting (words used more than once).
//Notice upper bound of for loops
//version2: create a copy of map in each loop to check if any word left. Check if words.size() words are used. 
//Notice the edge cases especially the last one!!!
vector<int> findSubstring(string s, vector<string>& words) {

	if (s.empty() || words.empty() || s.size() < words[0].size() * words.size()) {
		return {};
	}

	vector<int> result;

	unordered_map<string, int> wordsMap;
	//unordered_map<string, int> dupWords;
	for (int i = 0; i < words.size(); ++i) {
		++wordsMap[words[i]];
	}

	int len = words[0].size();
	int totalLen = words.size() * len;
	
	//NOTICE upper bound here !!
	for (int i = 0; i < s.size() - totalLen + 1; ++i) {
		unordered_map<string, int> usedWords;
		for (int j = i; j < i + totalLen; j = j + len) {
			string curStr = s.substr(j, len);
			if (wordsMap.count(curStr) && usedWords[curStr] < wordsMap[curStr]) {
				++usedWords[curStr];
			}
			else {
				break;
			}
			if (j == i + totalLen - len) {
				result.push_back(i);
			}
		}

	}
	return result;
}

//Version 2:
vector<int> findSubstring(string s, vector<string>& words) {

	//Notice the edge cases especially the last one!!!
	if (s.empty() || words.empty() || s.size() < words.size() * words[0].size()) {
		return {};
	}

	unordered_map<string, int> wordCounts;
	for (int i = 0; i < words.size(); ++i) {
		++wordCounts[words[i]];
	}
	vector<int> result;
	int len = words[0].size();

	//Notice ++i here, not i+=len;
	for (int i = 0; i < s.size(); ++i) {
		int cur = i;
		//Use the new map to check what word still left.
		unordered_map<string, int> oriMap(wordCounts);
		for (int j = 0; j < words.size(); ++j) {
			if (oriMap[s.substr(cur, len)] > 0) {
				--oriMap[s.substr(cur, len)];
			}
			else {
				break;
			}
			cur += len;
			if (j == words.size() - 1) {
				result.push_back(i);
			}
		}
	}
	return result;
}

/*
# 31. Next Permutation
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
*/

//traverse from end to begin to find the first element that less than its right element. Then swap this element with the smallest element of elements that are greater than it. Then reverse all elements behind the element.
//Notice the definition of next per
/*
如果从末尾往前看，数字逐渐变大，到了2时才减小的，然后我们再从后往前找第一个比2大的数字，是3，那么我们交换2和3，再把此时3后面的所有数字转置一下即可，步骤如下：

1　　2　　7　　4　　3　　1

1　　2　　7　　4　　3　　1

1　　3　　7　　4　　2　　1

1　　3　　1　　2　　4　　7
*/
//Notice the definition of next per
void nextPermutation(vector<int>& nums) {
	if (nums.size() <= 1) {
		return;
	}

	for (int i = nums.size() - 1; i > 0; --i) {
		if (nums[i - 1] < nums[i]) {
			for (int j = i; j < nums.size(); ++j) {
				if (nums[j] <= nums[i - 1]) {
					swap(nums[j - 1], nums[i - 1]);
					break;
				}
				else if (j == nums.size() - 1) {
					swap(nums[j], nums[i - 1]);
					break;
				}
			}
			reverse(nums.begin() + i, nums.end());
			return;
		}
	}
	reverse(nums.begin(), nums.end());
	return;
}

/*
# 32. Longest Valid Parentheses
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
Example 2:

Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
*/

//push index into stack
//use a current start pointer
//if new valid pars is found but stack if not empty, need to update result only between result and i - pars.top()
class Solution {
public:
	int longestValidParentheses(string s) {
		stack<int> pars;
		int result = 0;
		int curStart = 0;
		for (int i = 0; i < s.size(); ++i) {
			if (s[i] == '(') {
				pars.push(i);
			}
			else {
				if (pars.empty()) {
					curStart = i + 1;
				}
				else {
					pars.pop();
					result = pars.empty() ? max(result, i - curStart + 1) : max(result, i - pars.top());
				}
			}
		}
		return result;
	}
};

//Version two
int longestValidParentheses(string s) {
	stack<int> pars;
	int result = 0;
	int curMax = 0;
	for (int i = 0; i < s.size(); ++i) {
		if (s[i] == '(') {
			pars.push(i);
		}
		else {
			if (pars.empty()) {
				curMax = 0;
			}
			else {
				pars.pop();
				curMax += 2;
				if (pars.empty()) {
					result = max(result, curMax);
				}
				else {
					result = max(result, i - pars.top());
				}
			}
		}
	}
	return result;
}

/*
# 33. Search in Rotated Sorted Array
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
*/

//Abandon the part that target doesn't belong to
//Use binary search, firstly try to find where is the curve (in left or right part)!!
//Then check which part does target belongs to

int search(vector<int>& nums, int target) {

	if (nums.empty()) {
		return -1;
	}

	int left = 0;
	int right = nums.size() - 1;

	while (left < right - 1) {
		int mid = (right - left) / 2 + left;
		if (nums[mid] == target) {
			return mid;
		}
		if (nums[mid] > nums[right]) {
			if (target >= nums[left] && target < nums[mid]) {
				right = mid - 1;
			}
			else {
				left = mid + 1;
			}
		}
		else {
			if (target > nums[mid] && target <= nums[right]) {
				left = mid + 1;
			}
			else {
				right = mid - 1;
			}
		}
	}
	if (nums[left] == target) {
		return left;
	}
	else if (nums[right] == target) {
		return right;
	}
	else {
		return -1;
	}
}

/*
# 34. Find First and Last Position of Element in Sorted Array
Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
*/

//Use binary search, notice do not return directly when nums[mid] == target, let end = mid to keep the first pos in left part(if calc last pos, then let start =mid). Find the first pos firstly, then use a loop to find the last pos

vector<int> searchRange(vector<int>& nums, int target) {

	if (nums.empty()) {
		return { -1, -1 };
	}

	vector<int> result;
	int start = 0;
	int end = nums.size() - 1;

	//first:
	while (start + 1 < end) {
		int mid = (end - start) / 2 + start;
		if (nums[mid] == target) {
			end = mid;
		}
		else if (nums[mid] > target) {
			end = mid - 1;
		}
		else {
			start = mid + 1;
		}
	}

	if (nums[start] == target) {
		result.push_back(start);
		while (start + 1 < nums.size() && nums[start] == nums[start + 1]) {
			++start;
		}
		result.push_back(start);
		return result;
	}
	else if (nums[end] == target) {
		result.push_back(end);
		while (end + 1 < nums.size() && nums[end] == nums[end + 1]) {
			++end;
		}
		result.push_back(end);
		return result;
	}
	else {
		result.push_back(-1);
		result.push_back(-1);
		return result;
	}
}

/*
# 35. Search Insert Position
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Example 1:

Input: [1,3,5,6], 5
Output: 2
Example 2:

Input: [1,3,5,6], 2
Output: 1
Example 3:

Input: [1,3,5,6], 7
Output: 4
Example 4:

Input: [1,3,5,6], 0
Output: 0
*/

//Notice equaling case
int searchInsert(vector<int>& nums, int target) {

	if (nums.empty()) {
		return 0;
	}

	for (int i = 0; i < nums.size(); ++i) {
		if (target <= nums[i]) {
			return i;
		}
	}

	return nums.size();
}

/*
# 36. Valid Sudoku
Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition

Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.
The given board contain only digits 1-9 and the character '.'.
The given board size is always 9x9.
*/

//Use a map to store pos of digits.
//use /3 to check if in the same 3x3
bool isValidSudoku(vector<vector<char>>& board) {

	map<int, vector<vector<int>>> digitMap;

	for (int i = 0; i < board.size(); ++i) {
		for (int j = 0; j < board[i].size(); ++j) {
			int cur;
			if (board[i][j] == '.') {
				continue;
			}
			else {
				cur = board[i][j] - '0';
			}

			if (digitMap.count(cur)) {
				if (!ValidPos({ i,j }, digitMap[cur])) {
					return false;
				}
				else {
					digitMap[cur].push_back({ i,j });
				}
			}
			else {
				digitMap[cur] = { { i,j } };
			}
		}
	}
	return true;
}

bool ValidPos(vector<int> curPos, vector<vector<int>> existPos) {
	for (int i = 0; i < existPos.size(); ++i) {
		if (curPos[0] == existPos[i][0] || curPos[1] == existPos[i][1]) {
			return false;
		}
		else if (curPos[0] / 3 == existPos[i][0] / 3 && curPos[1] / 3 == existPos[i][1] / 3) {
			return false;
		}
	}
	return true;
}

/*
# 37. Sudoku Solver
Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy all of the following rules:

Each of the digits 1-9 must occur exactly once in each row.
Each of the digits 1-9 must occur exactly once in each column.
Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
Empty cells are indicated by the character '.'.

Note:

The given board contain only digits 1-9 and the character '.'.
You may assume that the given Sudoku puzzle will have a single unique solution.
The given board size is always 9x9.
*/

//fill in num one by one. valid the cur num in cur board firstly, then use recursion to check the rest.
//Notice if no result for any num, change the num back to '.' (back tracking). 
void solveSudoku(vector<vector<char>>& board) {
	recursiveSolver(board, 0, 0);
}

bool recursiveSolver(vector<vector<char>>& board, int row, int col) {
	if (row >= 9) {
		return true;
	}
	else if (col >= 9) {
		return recursiveSolver(board, row + 1, 0);
	}

	if (board[row][col] == '.') {
		for (int i = 1; i <= 9; ++i) {

			//Notice how to convert int to char
			board[row][col] = (char)(i + '0');
			if (validPos(board, row, col)) {
				//CANNOT return recursiveSolver(board, row + 1, 0), need to continue for loop !!!
				if (recursiveSolver(board, row, col + 1)) {
					return true;
				}
			}
			//board[row][col] = '.';
		}
		board[row][col] = '.';
	}
	else {
		return recursiveSolver(board, row, col + 1);
	}
	return false;
}

//Check if the current number is valid in current board
bool validPos(vector<vector<char>>& board, int i, int j) {
	for (int col = 0; col < 9; ++col) {
		if (col != j && board[i][j] == board[i][col]) {
			return false;
		}
	}

	for (int row = 0; row < 9; ++row) {
		if (row != i && board[i][j] == board[row][j]) {
			return false;
		}
	}

	//Notice * 3 here !!!
	//Notice upper bound here. Notice !(i == row && j == col)
	for (int m = i / 3 * 3; m < i / 3 * 3 + 3; ++m) {
		for (int n = j / 3 * 3; n < j / 3 * 3 + 3; ++n) {
			if (!(m == i && n == j) && (board[m][n] == board[i][j])) {
				return false;
			}
		}
	}

	return true;
}

/*
# 38. Count and Say
The count-and-say sequence is the sequence of integers with the first five terms as following:

1.     1
2.     11
3.     21
4.     1211
5.     111221
1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.

Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.

Note: Each term of the sequence of integers will be represented as a string.
*/

//Just read the (n-1)th string.//Notice how to handle converting among int, char and string.
string countAndSay(int n) {
	if (n == 1) {
		return "1";
	}
	string last = countAndSay(n - 1);
	string result = "";
	for (int i = 0; i < last.size(); ++i) {
		int curDig = last[i];
		int curCount = 1;
		while (i + 1 < last.size() && last[i] == last[i + 1]) {
			++curCount;
			++i;
		}
		result.append(to_string(curCount));
		result.push_back(last[i]);
	}
	return result;
}

/*
# 39. Combination Sum

Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
Example 2:

Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
*/

//Use PAC recursion. Notice how to set start (start = i because the num can be used unlimitly).
vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
	if (candidates.empty()) {
		return {};
	}
	vector<vector<int>> result = {};
	vector<int> cur = {};
	combinationRecur(candidates, target, cur, result, 0);
	return result;
}

void combinationRecur(vector<int>& candidates, int target, vector<int>& curSet, vector<vector<int>>& result, int start) {

	if (target == 0) {
		result.push_back(curSet);
		return;
	}
	else if (target < 0) {
		return;
	}

	for (int i = start; i < candidates.size(); ++i) {
		curSet.push_back(candidates[i]);
		combinationRecur(candidates, target - candidates[i], curSet, result, i);
		curSet.pop_back();
	}
}

/*
# 40. Combination Sum II
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
Example 2:

Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]
*/

//Notice how to set start and handle dup(sort firstly, skip dup in recursion)
vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
	if (candidates.empty()) {
		return {};
	}
	sort(candidates.begin(), candidates.end());
	vector<vector<int>> result = {};
	vector<int> cur = {};
	combinationRecur(candidates, target, cur, result, 0);
	return result;
}

void combinationRecur(vector<int>& candidates, int target, vector<int>& curSet, vector<vector<int>>& result, int start) {

	if (target == 0) {
		result.push_back(curSet);
		return;
	}
	else if (target < 0) {
		return;
	}

	for (int i = start; i < candidates.size(); ++i) {
		curSet.push_back(candidates[i]);
		combinationRecur(candidates, target - candidates[i], curSet, result, i + 1);
		curSet.pop_back();
		while (i + 1<candidates.size() && candidates[i] == candidates[i + 1]) {
			++i;
		}
	}
}

/*
# 46. Permutations
Given a collection of distinct integers, return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
*/
//Notice how to check if a num has been picked.
vector<vector<int>> permute(vector<int>& nums) {

	if (nums.empty()) {
		return {};
	}

	vector<vector<int>> result;
	vector<int> curSet;
	permuteRecursion(nums, curSet, 0, result, nums.size());
	return result;

}

void permuteRecursion(vector<int> nums, vector<int>& curSet, int start, vector<vector<int>>& result, int size) {

	if (curSet.size() == size) {
		result.push_back(curSet);
		return;
	}
	for (int i = 0; i < nums.size(); ++i) {
		curSet.push_back(nums[i]);
		vector<int> newSet(nums);
		newSet.erase(newSet.begin() + i);
		permuteRecursion(newSet, curSet, i, result, size);
		curSet.pop_back();
	}
}

/*
# 47. Permutations II
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:

Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
*/
//Note how to handle dup(sort firstly and skip dups in loop)
vector<vector<int>> permuteUnique(vector<int>& nums) {
	if (nums.empty()) {
		return {};
	}
	sort(nums.begin(), nums.end());
	vector<vector<int>> result;
	vector<int> curSet;
	permuteRecursion(nums, curSet, 0, result, nums.size());
	return result;
}

void permuteRecursion(vector<int> nums, vector<int>& curSet, int start, vector<vector<int>>& result, int size) {

	if (curSet.size() == size) {
		result.push_back(curSet);
		return;
	}
	for (int i = 0; i < nums.size(); ++i) {
		curSet.push_back(nums[i]);
		vector<int> newSet(nums);
		newSet.erase(newSet.begin() + i);
		permuteRecursion(newSet, curSet, i, result, size);
		curSet.pop_back();
		while (i + 1 <nums.size() && nums[i] == nums[i + 1]) {
			++i;
		}
	}
}

/*
# 41. First Missing Positive
Given an unsorted integer array, find the smallest missing positive integer.

Example 1:

Input: [1,2,0]
Output: 3
Example 2:

Input: [3,4,-1,1]
Output: 2
Example 3:

Input: [7,8,9,11,12]
Output: 1
Note:

Your algorithm should run in O(n) time and uses constant extra space.
*/

//put the positive num in the "correct" location(n should be put at index n-1)
//Then traverse the array again, return the first index that exists an "incorrect" num
int firstMissingPositive(vector<int>& nums) {

	if (nums.empty()) {
		return 1;
	}

	for (int i = 0; i < nums.size();) {
		if (nums[i] < nums.size() && nums[i] > 0 && nums[i] != nums[nums[i] - 1]) {
			swap(nums[i], nums[nums[i] - 1]);
		}
		else {
			++i;
		}
	}

	for (int i = 0; i < nums.size(); ++i) {
		if (nums[i] != i + 1) {
			return i + 1;
		}
	}
	return nums.size() + 1;
}

/*
# 10. Regular Expression Matching
Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input:
s = "aa"
p = "a*"
Output: true
Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
Example 3:

Input:
s = "ab"
p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
Example 4:

Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".
Example 5:

Input:
s = "mississippi"
p = "mis*is*p*."
Output: false
*/

//Use recursion by considering different cases of p. list exits(basic cases) firstly. Then check if the second element of p is *
bool isMatch(string s, string p) {

	if (s.empty() && p.empty()) {
		return true;
	}
	else if (p.empty()) {
		return false;
	}

	if (p.size() == 1) {
		if (s.size() == 1) {
			return (p == ".") || (s == p);
		}
		else {
			return false;
		}
	}

	if (p[1] != '*') {
		if (s.empty()) {
			return false;
		}
		else {
			//Check if the first char matches and then recursively check substr(1)
			return ((s[0] == p[0]) || (p[0] == '.')) && isMatch(s.substr(1), p.substr(1));
		}
	}
	else {
		
		//cut all repetitive chars in head.
		while (!s.empty() && (s[0] == p[0] || p[0] == '.')) {
			//For cases like ("aaa" and "a*a")
			if (isMatch(s, p.substr(2))) {
				return true;
			}
			s = s.substr(1);
		}
		
		//check recursively
		return isMatch(s, p.substr(2));
	}
}

//second version: //edge cases firstly !! //check by if s[1] is '*', subcheck 1:if s is empty 2:if (s[0] == p[0] || p[0] == '.')
bool isMatch(string s, string p) {
	
	//edge cases firstly !!
	if (s.empty() && p.empty()) {
		return true;
	}
	else if (p.empty()) {
		return false;
	}

	if (p.size() == 1) {
		if (s.size() == 1 && (s[0] == p[0] || p[0] == '.')) {
			return true;
		}
		else {
			return false;
		}
	}
	
	//check by if [1] is '*'
	//Then check if s is empty, then if (s[0] == p[0] || p[0] == '.')
	if (p[1] != '*') {
		//Notice to check if s is empty here
		if (s.empty()) {
			return false;
		}
		else if (s[0] == p[0] || p[0] == '.') {
			return isMatch(s.substr(1), p.substr(1));
		}
		else {
			return false;
		}
	}
	else {
		//Notice to check if s is empty here
		if (s.empty()) {
			return isMatch(s, p.substr(2));
		}
		else if (p[0] == '.' || s[0] == p[0]) {
			//here notice always check if it matches when * represents "zero pre"
			return isMatch(s.substr(1), p) || isMatch(s, p.substr(2));
		}
		else {
			return isMatch(s, p.substr(2));
		}
	}
}


/*
# 42. Trapping Rain Water
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!
Example:

Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
*/

//Two pointers head and tail. Move the lower one to center, if the "next one" is even lower then increase result, else move head/tail to the index and compare head and tail (new loop).
int trap(vector<int>& height) {

	if (height.size() <= 2) {
		return 0;
	}

	int left = 0;
	int right = height.size() - 1;
	int result = 0;
	int curTrap = 0;

	while (left < right) {
		if (height[left] < height[right]) {
			int curRight = left + 1;
			while (height[left] > height[curRight]) {
				result += height[left] - height[curRight];
				++curRight;
			}
			left = curRight;
		}
		else {
			int curLeft = right - 1;
			while (height[curLeft] < height[right]) {
				result += height[right] - height[curLeft];
				--curLeft;
			}
			right = curLeft;
		}
	}
	return result;
}

/*
# 43. Multiply Strings
Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.

Example 1:

Input: num1 = "2", num2 = "3"
Output: "6"
Example 2:

Input: num1 = "123", num2 = "456"
Output: "56088"
Note:

The length of both num1 and num2 is < 110.
Both num1 and num2 contain only digits 0-9.
Both num1 and num2 do not contain any leading zero, except the number 0 itself.
You must not use any built-in BigInteger library or convert the inputs to integer directly.
*/

//Multiply by bit and store results in an array. Then add the results of all bit products, notice to handle carries.//Notice to remove dup '0'.
//Notice how to store the products and the index
string multiply(string num1, string num2) {
	if (num1 == "0" || num2 == "0") {
		return "0";
	}

	string resStr;
	int res = 0;
	int len1 = num1.size();
	int len2 = num2.size();
	vector<int> products(len1 + len2, 0);
	for (int i = len1 - 1; i >= 0; --i) {
		for (int j = len2 - 1; j >= 0; --j) {
			//Notice the += here !!!
			//Notice the index here !!! Store the low bit result in the tail of array to handle carries later.
			products[len1 + len2 - 1 - 1 - (i + j)] += (num1[i] - '0') * (num2[j] - '0');
		}
	}

	int carry = 0;
	for (int i = 0; i < products.size(); ++i) {
		products[i] += carry;
		carry = products[i] / 10;
		products[i] %= 10;
	}

	//Remove zeros
	int tail = products.size() - 1;
	while (products[tail] == 0) {
		--tail;
	}

	for (int i = tail; i >= 0; --i) {
		resStr.push_back((char)(products[i] + '0'));
	}
	return resStr;
}

/*
# 44. Wildcard Matching
Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.

'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like ? or *.
Example 1:

Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input:
s = "aa"
p = "*"
Output: true
Explanation: '*' matches any sequence.
Example 3:

Input:
s = "cb"
p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.
Example 4:

Input:
s = "adceb"
p = "*a*b"
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".
Example 5:

Input:
s = "acdcb"
p = "a*c?b"
Output: false
*/
bool isMatch(char *s, char *p) {
    char *scur = s, *pcur = p, *sstar = NULL, *pstar = NULL;
    while (*scur) {
        if (*scur == *pcur || *pcur == '?') {
            ++scur;
            ++pcur;
        } else if (*pcur == '*') {
            pstar = pcur++;
            sstar = scur;
        } else if (pstar) {
            pcur = pstar + 1;
            scur = ++sstar;
        } else return false;
    } 
    while (*pcur == '*') ++pcur;
    return !*pcur;
}

/*
# 45 Jump Game II
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

Example:

Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.
Note:

You can assume that you can always reach the last index.
*/
//Calc a farest pos and its base pos. Then traverse in the range from base pos and farest pos to calc next farest pos.
//Notice how to handle the result accumulation. 
//Method1:
int jump(vector<int>& nums) {
	if (nums.size() <= 1) {
		return 0;
	}

	int newMaxIndex = 0;
	int currentMaxIndex = 0;
	int minSteps = 0;
	int currentIndex = 0;

	while (newMaxIndex < nums.size() - 1) {

		//Foward a step
		++minSteps;
		//Current max scope we can touch
		currentMaxIndex = newMaxIndex;

		//Search in current scope(from last max index to current max index)
		for (;currentIndex <= currentMaxIndex; ++currentIndex) {
			newMaxIndex = max(newMaxIndex, currentIndex + nums[currentIndex]);
		}
	}
	return minSteps;
}

//Method2
int jump(vector<int>& nums) {
	if (nums.empty() || nums.size() == 1) {
		return 0;
	}
	//range of step 1 is easy to know
	int farest = nums[0];
	int curStart = 0;
	int result = 1;
	//Notice condition is farest < nums.size() - 1
	while (farest < nums.size() - 1) {
		//Need this to be a fixed border of for loop
		int curFarest = farest;
		//farest = curStart + nums[curStart];
		for (int i = curStart; i <= curFarest; ++i) {
			if (i + nums[i] > farest) {
				farest = i + nums[i];
				curStart = i;
				if (farest >= nums.size() - 1) {
					++result;
					return result;
				}
			}
		}
		++result;
	}
	return result;
}

/*
# 48. Rotate Image
You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Note:

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:

Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
*/
//method1: rotate elements by counterclock dir for 3 times.Notice upper bound in the loops.
//method2: step1: reverse by the diagonal (the line m[0][n - 1] ~ m[n - 1][0]). step2: reverse by the line m[n/2](reverse each col)
//method3: step1: reverse by the diagonal (the line m[0][0] ~ m[n - 1][n - 1]). step2: reverse each row;
void rotate(vector<vector<int>>& matrix) {
	int n = matrix.size();
	for (int i = 0; i < matrix.size() / 2; ++i) {
		for (int j = i; j <= n - 1 - i - 1; ++j) {
			swap(matrix[i][j], matrix[n - 1 - j][i]);
			swap(matrix[n - 1 - j][i], matrix[n - 1 - i][n - 1 - j]);
			swap(matrix[n - 1 - i][n - 1 - j], matrix[j][n - 1 - i]);
		}
	}
}

/*
# 49. Group Anagrams
Given an array of strings, group anagrams together.

Example:

Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
Note:

All inputs will be in lowercase.
The order of your output does not matter.
*/

//Remember all anagrams have the same sorted result !
//Create a map, use sorted result as the key, all anagrams as value.
vector<vector<string>> groupAnagrams(vector<string>& strs) {

	vector<vector<string>> res;

	unordered_map<string, vector<string>> anaMap;
	for (int i = 0; i < strs.size(); ++i) {
		string cur = strs[i];
		//MUST HAVE WHEN SUBMIT
		sort(cur.begin(), cur.end());
		anaMap[cur].push_back(strs[i]);
	}

	for (auto pair : anaMap) {
		res.push_back(pair.second);
	}

	return res;
}

/*
# 50. Pow(x, n)
Implement pow(x, n), which calculates x raised to the power n (xn).

Example 1:

Input: 2.00000, 10
Output: 1024.00000
Example 2:

Input: 2.10000, 3
Output: 9.26100
Example 3:

Input: 2.00000, -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
Note:

-100.0 < x < 100.0
n is a 32-bit signed integer, within the range
*/

//Recursive. Use half(/2) method to avoid ETL. Notice how to handle negative n.
double myPow(double x, int n) {

	if (n == 0) {
		return 1;
	}
	else if (n == 1) {
		return x;
	}

	double half = myPow(x, n / 2);
	if (n % 2 == 0) {
		return half * half;
	}
	else if (n > 0) {
		return half * half * x;
	}
	else {
		return half * half / x;
	}
}

/*
# 51. N-Queens
The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.
Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

Example:

Input: 4
Output: [
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.
*/

//Recursion and back tracking.
//Use an array to store the col of each row(index is row, value is col). Notice the initial value -1 of queenRowLoc is necessary.
vector<vector<string>> solveNQueens(int n) {
	vector<int> queenRowLoc(n, -1);
	//vector<vector<string>> result(n, vector<string>(n));
	vector<vector<string>> result;
	RecurSolver(queenRowLoc, 0, result);
	return result;
}

//DFS row by row
void RecurSolver(vector<int>& board, int row, vector<vector<string>>& res) {

	int size = board.size();
	
	//When all rows are done, update result;
	if (row == size) {
		vector<string> curSolution;
		for (int i = 0; i < size; ++i) {
			string curRow;
			for (int j = 0; j < size; ++j) {
				if (board[i] == j) {
					curRow.push_back('Q');
				}
				else {
					curRow.push_back('.');
				}
			}
			curSolution.push_back(curRow);
		}
		res.push_back(curSolution);
		return;
	}

	for (int i = 0; i < size; ++i) {
		board[row] = i;
		if (isValid(board, row, i)) {
			RecurSolver(board, row + 1, res);
		}
		//back tracking here.
		board[row] = -1;
	}
}

//Don't need to check row because DFS is done row by row.
//Check col and diagnose
bool isValid(vector<int>& board, int row, int col) {
	//int size = board.size();
	for (int i = 0; i < row; ++i) {
		if (board[i] == col || abs(board[i] - col) == abs(i - row)) {
			return false;
		}
	}
	return true;
}

//Version 2:
vector<vector<string>> solveNQueens(int n) {
	vector<vector<string>> result;
	//vector<vector<int>> queenMap(n, vector<int>(n, 0));
	vector<int> queenRowPos(n, -1);
	NQueensSolver(queenRowPos, result, 0);
	return result;
}

void NQueensSolver(vector<int>& board, vector<vector<string>>& res, int row) {

	if (row >= board.size()) {
		vector<string> curSol;
		for (int i = 0; i < board.size(); ++i) {
			string curRow(board.size(), '.');
			curRow[board[i]] = 'Q';
			curSol.push_back(curRow);
		}
		res.push_back(curSol);
	}

	for (int i = 0; i < board.size(); ++i) {
		if (isValidPos(board, row, i)) {
			board[row] = i;
			NQueensSolver(board, res, row + 1);
			board[row] = -1;
		}
	}
}

bool isValidPos(vector<int>& board, int row, int col) {
	for (int i = 0; i < row; ++i) {
		if (board[i] == col || abs(board[i] - col) == abs(i - row)) {
			return false;
		}
	}
	return true;
}

/*
# 53. Maximum Subarray
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
*/

//method1: dp
//method2: d and c
int maxSubArray(vector<int>& nums) {
        
        if(nums.empty()) {
            return 0;
        }
        
        int result = INT_MIN;
        int curSum = 0;
        
        for(int i = 0; i < nums.size(); ++i){
        	//dp here
            curSum = max(curSum + nums[i], nums[i]);
            result = max(result, curSum);
        }
        
        return result;
    }
    
/*
# 54. Spiral Matrix
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

Example 1:

Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]
Example 2:

Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
*/

//Do like what a human does this. cycle by cycle. Notice how to compute totalcycle
//Notice how to check loop bounders. 
vector<int> spiralOrder(vector<vector<int>>& matrix) {

	if (matrix.empty()) {
		return {};
	}

	int curCycle = 0;
	vector<int> result;
	int totalCycle = (min(matrix.size(), matrix[0].size()) + 1) / 2;
	for (int i = 0; i < totalCycle; ++i) {
		clockwiseSearch(i, matrix, result);
	}
	return result;
}

void clockwiseSearch(int cycle, vector<vector<int>>& matrix, vector<int>& result) {
	int i = cycle;
	int j = cycle;

	while (j < matrix[cycle].size() - cycle) {
		result.push_back(matrix[i][j]);
		++j;
	}
	//Remember to adjust i,j when one border is done.
	++i;
	--j;

	while (i < matrix.size() - cycle) {
		result.push_back(matrix[i][j]);
		++i;
	}
	--j;
	--i;
	
	//Remember to check if the cycle is only "one row or one col"
	if (matrix[cycle].size() - 2 * cycle == 1 || matrix.size() - 2 * cycle == 1) {
		return;
	}
	
	//Notice the loop bounder !!
	while (j >= cycle) {
		result.push_back(matrix[i][j]);
		--j;
	}

	--i;
	++j;
	while (i > cycle) {
		result.push_back(matrix[i][j]);
		--i;
	}
}

/*
# 56. Merge Intervals
Given a collection of intervals, merge all overlapping intervals.

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
*/
//Sort firstly !!! Notice how to use lambda. //put the first element to result and then traverse inputs and compare with the last element in result.
vector<Interval> merge(vector<Interval>& intervals) {

	if (intervals.size() <= 1) {
		return intervals;
	}

	int size = intervals.size();

	vector<Interval> result;
	sort(intervals.begin(), intervals.end(), [](Interval &a, Interval &b) {return a.start < b.start;});

	result.push_back(intervals[0]);

	for (int i = 1; i < intervals.size(); ++i) {
		if (result.back().end >= intervals[i].start) {
			result.back().end = max(result.back().end, intervals[i].end);
		}
		else {
			result.push_back(intervals[i]);
		}
	}
	return result;
}

/*
# 57. Insert Interval
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

Example 1:

Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
Example 2:

Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
*/

//step1: find where to insert. step2: insert separately or merge and insert. step3:For rest elements, insert separately or merge and insert.
vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {
	if (intervals.empty()) {
		return { newInterval };
	}

	vector<Interval> result;
	int insertIndex = -1;
	
	//Compare end and start to find insert index
	for (int i = 0; i < intervals.size(); ++i) {
		if (intervals[i].end < newInterval.start) {
			result.push_back(intervals[i]);
		}
		else {
			insertIndex = i;
			break;
		}
	}

	if (insertIndex == -1) {
		result.push_back(newInterval);
		return result;
	}
	
	//Check how to insert(merge or insert separately)
	if (newInterval.end < intervals[insertIndex].start) {
		result.push_back(newInterval);
		result.push_back(intervals[insertIndex]);
	}
	else {
		Interval newInter(min(newInterval.start, intervals[insertIndex].start), max(newInterval.end, intervals[insertIndex].end));
		result.push_back(newInter);
	}
	
	//handle rest elements
	for (int i = insertIndex + 1; i < intervals.size(); ++i) {
		if (result.back().end >= intervals[i].start) {
			result.back().end = max(result.back().end, intervals[i].end);
		}
		else {
			result.push_back(intervals[i]);
		}
	}
	return result;
}
//Version2:compare intervals[i].start and newInterval.start. Notice how to handle when pos = -1
vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {
	if (intervals.empty()) {
		return { newInterval };
	}

	vector<Interval> result;
	int pos = -1;
	for (int i = 0; i < intervals.size(); ++i) {
		if (intervals[i].start > newInterval.start) {
			pos = i;
			break;
		}
		else {
			result.push_back(intervals[i]);
		}
	}
	//Put newInterval into result. Notice edge case here!
	if (pos == -1) {
		if (result.back().end >= newInterval.start) {
			result.back().end = max(result.back().end, newInterval.end);
		}
		else {
			result.push_back(newInterval);
		}
		return result;
	}
	else if (pos > 0 && result.back().end >= newInterval.start) {
		result.back().end = max(result.back().end, newInterval.end);
	}
	else {
		result.push_back(newInterval);
	}

	for (int i = pos; i < intervals.size(); ++i) {
		if (result.back().end >= intervals[i].start) {
			result.back().end = max(result.back().end, intervals[i].end);
		}
		else {
			result.push_back(intervals[i]);
		}
	}

	return result;
}

/*
# 58. Length of Last Word
Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

If the last word does not exist, return 0.

Note: A word is defined as a character sequence consists of non-space characters only.

Example:

Input: "Hello World"
Output: 5
*/
//step1: start traversing from tail, skip ' ' in the tail and find the first element that is char.
//step2: continue traverse use loop and ++result until the first ' '. 
int lengthOfLastWord(string s) {
	if (s.empty()) {
		return 0;
	}
	int result = 0;
	int notSpaceIndex = s.size() - 1;
	while (notSpaceIndex >= 0 && s[notSpaceIndex] == ' ') {
		--notSpaceIndex;
	}
	if (notSpaceIndex < 0) {
		return 0;
	}

	while (notSpaceIndex >= 0 && s[notSpaceIndex] != ' ') {
		--notSpaceIndex;
		++result;
	}
	return result;
	/*for(int i = notSpaceIndex; i >= 0; --i){
	if(s[i] == ' '){
	return notSpaceIndex - i;
	} else if(i == 0){
	return notSpaceIndex + 1;
	}
	}
	return s.size();*/
}

/*
# 59. Spiral Matrix II
Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

Example:

Input: 3
Output:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
*/

//Handle it cycle by cycle; Notice loop borders

vector<vector<int>> generateMatrix(int n) {
	int cycle = (n + 1) / 2;
	vector<vector<int>> result(n, vector<int>(n, -1));
	int start = 1;

	for (int i = 0; i < cycle; ++i) {
		start = insertCycle(i, result, start);
	}
	return result;
}

int insertCycle(int curCyc, vector<vector<int>>& result, int startNum) {

	int size = result.size();
	int row = curCyc;
	//int col = curCyc;
	for (int col = curCyc; col < size - curCyc; ++col) {
		result[curCyc][col] = startNum;
		++startNum;
	}

	for (int row = curCyc + 1; row < size - curCyc; ++row) {
		result[row][size - curCyc - 1] = startNum;
		++startNum;
	}

	for (int col = size - curCyc - 2; col >= curCyc; --col) {
		result[size - curCyc - 1][col] = startNum;
		++startNum;
	}

	for (int row = size - curCyc - 2; row > curCyc; --row) {
		result[row][curCyc] = startNum;
		++startNum;
	}

	return startNum;
}

/*
# 60. Permutation Sequence
The set [1,2,3,...,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order, we get the following sequence for n = 3:

"123"
"132"
"213"
"231"
"312"
"321"
Given n and k, return the kth permutation sequence.

Note:

Given n will be between 1 and 9 inclusive.
Given k will be between 1 and n! inclusive.
Example 1:

Input: n = 3, k = 3
Output: "213"
Example 2:

Input: n = 4, k = 9
Output: "2314"
*/

//Try to find connection between the order and index of each digit.
//Create an array to store factorials.
//Remember to erase a digit after selecting it.
string getPermutation(int n, int k) {

	string seq(n, -1);
	string result(n, -1);
	vector<int> fac(n, -1);
	for (int i = 0; i < n; ++i) {
		seq[i] = (char)(i + 1 + '0');
	}
	fac[0] = 1;
	for (int i = 1; i < n; ++i) {
		fac[i] = fac[i - 1] * (i);
	}

	int kIndex = k - 1;
	for (int i = 0; i < n; ++i) {
		result[i] = seq[kIndex / fac[n - 1 - i]];
		seq.erase(seq.begin() + kIndex / fac[n - 1 - i]);
		
		//equals to kIndex %= fac[n - 1 - i];
		kIndex = kIndex - (kIndex / fac[n - 1 - i]) * fac[n - 1 - i];
	}

	return result;
}

/*
# 61. Rotate List
Given a linked list, rotate the list to the right by k places, where k is non-negative.

Example 1:

Input: 1->2->3->4->5->NULL, k = 2
Output: 4->5->1->2->3->NULL
Explanation:
rotate 1 steps to the right: 5->1->2->3->4->NULL
rotate 2 steps to the right: 4->5->1->2->3->NULL
Example 2:

Input: 0->1->2->NULL, k = 4
Output: 2->0->1->NULL
Explanation:
rotate 1 steps to the right: 2->0->1->NULL
rotate 2 steps to the right: 1->2->0->NULL
rotate 3 steps to the right: 0->1->2->NULL
rotate 4 steps to the right: 2->0->1->NULL
*/

//step 1: find size of the list and compute the newK(remove dup loops). step 2: find the last (newK th) pre node. 
//step 3: Move nodes to head, notice to move head to keep the order beacuse it is not reversing.
//method2: cut the list and move the entire tail to head.
ListNode* rotateRight(ListNode* head, int k) {

	if (!head || !head->next) {
		return head;
	}

	ListNode dummyHead(-1);
	//ListNode* left = head;
	//ListNode* right = head;
	dummyHead.next = head;
	ListNode* preTail = head;
	head = &dummyHead;

	int size = 1;
	while (preTail->next) {
		preTail = preTail->next;
		++size;
	}

	preTail = head;
	int newK = k%size;
	//int newK = 2;
	//size = 5;
	for (int i = 0; i < size - newK; ++i) {
		preTail = preTail->next;
	}

	for (int i = 0; i < newK; ++i) {
		ListNode* tmp = preTail->next;
		preTail->next = tmp->next;
		tmp->next = head->next;
		head->next = tmp;

		//It is not reverse !!! so need to add this to keep the order !!
		head = head->next;
	}

	return dummyHead.next;
}

/*
# 62. Unique Paths
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?
Note: m and n will be at most 100.

Example 1:

Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
Example 2:

Input: m = 7, n = 3
Output: 28
*/

//Use dp. Notice the grid is symmetrical.
int uniquePaths(int m, int n) {
	if (m == 1 || n == 1) {
		return 1;
	}

	vector<vector<int>> grid(m, vector<int>(n, 0));
	//int result = 0;
	//result = divideConquer(1,0, grid) + divideConquer(0,1, grid);

	for (int i = 0; i < n; ++i) {
		grid[0][i] = 1;
	}

	for (int i = 0; i < m; ++i) {
		grid[i][0] = 1;
	}

	for (int i = 1; i < m; ++i) {
		for (int j = 1; j < n; ++j) {
			grid[i][j] = grid[i - 1][j] + grid[i][j - 1];
		}
	}

	return grid[m - 1][n - 1];
}

//DC method but TLE
int uniquePaths(int m, int n) {
	if (m == 1 || n == 1) {
		return 1;
	}

	vector<vector<int>> grid(m, vector<int>(n, 0));
	int result = 0;
	result = divideConquer(1, 0, grid) + divideConquer(0, 1, grid);
	return result;
}

int divideConquer(int m, int n, vector<vector<int>>& grid) {
	int rows = grid.size();
	int cols = grid[0].size();
	if (((m == rows - 2) && (n == cols - 1)) || ((m == rows - 1) && (n == cols - 2))) {
		return 1;
	}

	if (m == rows - 1) {
		return divideConquer(m, n + 1, grid);
	}
	else if (n == cols - 1) {
		return divideConquer(m + 1, n, grid);
	}
	else {
		return divideConquer(m, n + 1, grid) + divideConquer(m + 1, n, grid);
	}
}

/*
# 63. Unique Paths II
Now consider if some obstacles are added to the grids. How many unique paths would there be?
Example 1:

Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
*/

//Add conditions to check if there is obstacle.
//Notice new edge cases
int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {

	if (obstacleGrid.empty()) {
		return 0;
	}
	else if (obstacleGrid[0].empty()) {
		return 0;
	}
	else if (obstacleGrid[0][0] == 1) {
		return 0;
	}

	int m = obstacleGrid.size();
	int n = obstacleGrid[0].size();

	vector<vector<int>> grid(m, vector<int>(n, 0));

	grid[0][0] = 1;
	for (int i = 1; i < n; ++i) {
		if (obstacleGrid[0][i] != 1) {
			grid[0][i] = grid[0][i - 1];
		}
	}

	for (int i = 1; i < m; ++i) {
		if (obstacleGrid[i][0] != 1) {
			grid[i][0] = grid[i - 1][0];
		}
	}

	for (int i = 1; i < m; ++i) {
		for (int j = 1; j < n; ++j) {
			if (obstacleGrid[i][j] != 1) {
				grid[i][j] = grid[i - 1][j] + grid[i][j - 1];
			}
		}
	}

	return grid[m - 1][n - 1];
}

/*
# 65. Valid Number
Validate if a given string can be interpreted as a decimal number.

Some examples:
"0" => true
" 0.1 " => true
"abc" => false
"1 a" => false
"2e10" => true
" -90e3   " => true
" 1e" => false
"e3" => false
" 6e-1" => true
" 99e2.5 " => false
"53.5e93" => true
" --6 " => false
"-+3" => false
"95a54e53" => false

Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:

Numbers 0-9
Exponent - "e"
Positive/negative sign - "+"/"-"
Decimal point - "."
Of course, the context of these characters also matters in the input.

Update (2015-02-10):
The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button to reset your code definition.
*/
//regex
public static void main(String[] args) {
 
	}
 
	public boolean isNumber(String s) {
        if(s.trim().isEmpty()){
        	return false;
        }
        String regex = "[-+]?(\\d+\\.?|\\.\\d+)\\d*(e[-+]?\\d+)?";
        if(s.trim().matches(regex)){
        	return true;
        }else{
        	return false;
        }
}
--------------------- 
作者：chiiis 
来源：CSDN 
原文：https://blog.csdn.net/fightforyourdream/article/details/12900751 
版权声明：本文为博主原创文章，转载请附上博文链接！

/*
# 66. Plus One
Given a non-empty array of digits representing a non-negative integer, plus one to the integer.

The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.

You may assume the integer does not contain any leading zero, except the number 0 itself.

Example 1:

Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Example 2:

Input: [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
*/

//notice how to handle the carry and potential new head.
vector<int> plusOne(vector<int>& digits) {
	
	//add one any way. so initial is 1;
	int carry = 1;
	int cur = digits.size() - 1;
	while (carry != 0 && cur >= 0) {
		digits[cur] = digits[cur] + carry;
		if (digits[cur] == 10) {
			digits[cur] = 0;
			carry = 1;
			
			//potential new head
			if (cur == 0) {
				digits.insert(digits.begin(), 1);
				return digits;
			}
		}
		else {
			carry = 0;
		}
		--cur;
	}
	return digits;
}

/*
# 67. Add Binary
Given two binary strings, return their sum (also a binary string).

The input strings are both non-empty and contains only characters 1 or 0.

Example 1:

Input: a = "11", b = "1"
Output: "100"
Example 2:

Input: a = "1010", b = "1011"
Output: "10101"
*/
//notice how to convert between char and int.
string addBinary(string a, string b) {
	string result;

	int sizeA = a.size();
	int sizeB = b.size();
	int pa = sizeA - 1;
	int pb = sizeB - 1;

	char carry = 0;

	while (pa >= 0 || pb >= 0) {
		int cur = 0;
		if (pa < 0) {
			cur = (b[pb] - '0') + carry;
		}
		else if (pb < 0) {
			cur = (a[pa] - '0') + carry;
		}
		else {
			cur = (a[pa] - '0') + (b[pb] - '0') + carry;
		}

		if (cur == 0) {
			result.insert(result.begin(), '0');
			carry = 0;
		}
		else if (cur == 1) {
			result.insert(result.begin(), '1');
			carry = 0;
		}
		else if (cur == 2) {
			result.insert(result.begin(), '0');
			carry = 1;
		}
		else if (cur == 3) {
			result.insert(result.begin(), '1');
			carry = 1;
		}

		--pa;
		--pb;
	}

	if (carry == 1) {
		result.insert(result.begin(), '1');
	}
	return result;
}

/*
# 69. Sqrt(x)
Implement int sqrt(int x).

Compute and return the square root of x, where x is guaranteed to be a non-negative integer.

Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.

Example 1:

Input: 4
Output: 2
Example 2:

Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since 
             the decimal part is truncated, 2 is returned.
*/

//try to find the LAST res that res * res <= x.
//Use binary search to improve eff.
int mySqrt(int x) {
	if (x <= 1) {
		return x;
	}
	int low = 0;
	int high = x;
	while (low - 1 < high) {
		int mid = (high - low) / 2 + low;
		if (mid > x / mid) {
			high = mid - 1;
		}
		else if (mid < x / mid) {
			low = mid + 1;
		}
		else {
			return mid;
		}
	}
	if (high > x / high) {
		return low;
	}
	else {
		return high;
	}
	//return low;
}

//Version 2. Notice while loop condition !!
int mySqrt(int x) {
        if(x <= 1){
            return x;
        }
        int low = 0;
        int high = x;
        while(low + 1 < high){
            int mid = (high - low)/2 + low;
            if(mid > x/mid){                
                high = mid - 1;
            } else if(mid < x/mid) {                
                low = mid;
            } else {
                return mid;
            }
        }
        if(high > x/high){
            return low;
        } else {
            return high;
        }
        //return low;
    }

/*
# 71. Simplify Path
Given an absolute path for a file (Unix-style), simplify it. 

For example,
path = "/home/", => "/home"
path = "/a/./b/../../c/", => "/c"
path = "/a/../../b/../c//.//", => "/c"
path = "/a//b////c/d//././/..", => "/a/b/c"

In a UNIX-style file system, a period ('.') refers to the current directory, so it can be ignored in a simplified path. Additionally, a double period ("..") moves up a directory, so it cancels out whatever the last directory was. For more information, look here: https://en.wikipedia.org/wiki/Path_(computing)#Unix_style

Corner Cases:

Did you consider the case where path = "/../"?
In this case, you should return "/".
Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".
In this case, you should ignore redundant slashes and return "/home/foo".
*/

//Notice how to cut string (two pointer and substr).
string simplifyPath(string path) {

	if (path == "/") {
		return "/";
	}

	vector<string> dir;
	//dir.push_back("/");
	int cur = 0;
	int head = 0;
	int tail = 0;

	while (tail < path.size() && head < path.size()) {

		while (head < path.size() && path[head] == '/') {
			++head;
		}
		if (head == path.size()) {
			break;
		}
		tail = head;
		while (tail < path.size() && path[tail] != '/') {
			++tail;
		}

		/*if(tail == path.size()){
		--tail;
		}*/

		string curStr = path.substr(head, tail - head);
		if (curStr == ".") {

		}
		else if (curStr == "..") {
			if (!dir.empty()) {
				dir.pop_back();
			}
		}
		else {
			dir.push_back(curStr);
		}
		head = tail;
	}

	string result;
	if (dir.empty()) {
		return "/";
	}

	for (int i = 0; i < dir.size(); ++i) {
		/*if(dir[i] != ""){
		result.push_back('/');
		result.append(dir[i]);
		} */
		result.push_back('/');
		result.append(dir[i]);
	}
	return result;
}

/*
# 72. Edit Distance
Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

You have the following 3 operations permitted on a word:

Insert a character
Delete a character
Replace a character
Example 1:

Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
Example 2:

Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
*/

//DP,maintain a dp table. Notice the connection/difference between this problem and LCS below.
//initial border values are i. dp[i][j] represents the minimum number of operations from first i chars in word1 to first j chars in word2
//Notice the first char is empty.
//Notice the formula needs the min of THREE elements
int minDistance(string word1, string word2) {

	if (word1.size() == 0) {
		return word2.size();
	}
	else if (word2.size() == 0) {
		return word1.size();
	}

	int len1 = word1.size();
	int len2 = word2.size();

	vector<vector<int>> minMap(len1 + 1, vector<int>(len2 + 1, 0));
	/*if(word1[0] == word2[0]){
	minMap[0][0] = 0;
	} else {
	minMap[0][0] = 1;
	}*/
	minMap[0][0] = 0;
	for (int i = 1; i < len1 + 1; ++i) {
		/*if(word1[i] == word2[0]){
		minMap[i][0] = minMap[i - 1][0];
		} else {
		minMap[i][0] = minMap[i - 1][0] + 1;
		}*/
		minMap[i][0] = i;
	}
	for (int i = 1; i < len2 + 1; ++i) {
		/*if(word1[0] == word2[i]){
		minMap[0][i] = minMap[0][i - 1];
		} else {
		minMap[0][i] = minMap[0][i - 1] + 1;
		}*/
		minMap[0][i] = i;
	}

	for (int i = 1; i < len1 + 1; ++i) {
		for (int j = 1; j < len2 + 1; ++j) {
			if (word1[i - 1] == word2[j - 1]) {
				minMap[i][j] = minMap[i - 1][j - 1];
			}
			else {
				int minCur = min(minMap[i - 1][j - 1], minMap[i - 1][j]);
				minMap[i][j] = min(minCur, minMap[i][j - 1]) + 1;
			}
		}
	}
	return minMap[len1][len2];
	//return minMap[1][1];
}

/*
#lintcode 77
Given two strings, find the longest common subsequence (LCS).

Your code should return the length of LCS.
*/
//initial border values are 0
int LongestComSubSeq(string &s1, string &s2) {
	
	int len1 = s1.size();
	int len2 = s2.size();

	//Update the table.longestComTable[i][j] represents that the max common sub seq length of s1[0]~s1[i-1] and s2[0]~s2[j-1]
	vector<vector<int>> longestComTable(len1+1, vector<int>(len2+1,0));
	for (int i = 1; i < len1 + 1;++i) {
		for (int j = 1; j < len2 + 1; ++j) {
			longestComTable[i][j] = _Max_value(longestComTable[i-1][j], longestComTable[i][j - 1]);
			if (s1[i - 1] == s2[j - 1]) {
				longestComTable[i][j] = longestComTable[i - 1][j - 1] + 1;
			}
		}
	}
	return longestComTable[len1][len2];
}

/*
# 73. Set Matrix Zeroes
Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.

Example 1:

Input: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
Example 2:

Input: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
Follow up:

A straight forward solution using O(mn) space is probably a bad idea.
A simple improvement uses O(m + n) space, but still not the best solution.
Could you devise a constant space solution?
*/

//Use two arrays to store zero locations. Notice how to handle dups
void setZeroes(vector<vector<int>>& matrix) {
	vector<int> rowZero;
	vector<int> colZero;

	for (int i = 0; i < matrix.size(); ++i) {
		for (int j = 0; j < matrix[0].size(); ++j) {
			if (matrix[i][j] == 0) {

				if (rowZero.empty()) {
					rowZero.push_back(i);
				}
				else if (rowZero.back() != i) {
					rowZero.push_back(i);
				}
			}
		}
	}

	for (int i = 0; i < matrix[0].size(); ++i) {
		for (int j = 0; j < matrix.size(); ++j) {
			if (matrix[j][i] == 0) {

				if (colZero.empty()) {
					colZero.push_back(i);
				}
				else if (colZero.back() != i) {
					colZero.push_back(i);
				}
				//colZero.push_back(j);
			}
		}
	}

	for (int i = 0; i < rowZero.size(); ++i) {
		for (int j = 0; j < matrix[0].size(); ++j) {
			matrix[rowZero[i]][j] = 0;
		}
	}

	for (int i = 0; i < colZero.size(); ++i) {
		for (int j = 0; j < matrix.size(); ++j) {
			matrix[j][colZero[i]] = 0;
		}
	}
}
/*
# 74. Search a 2D Matrix
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
Example 1:

Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true
Example 2:

Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
Output: false
*/

//Use binary search, notice when find row, top = mid not top = mid + 1, because the target may be in the line. 
bool searchMatrix(vector<vector<int>>& matrix, int target) {

	if (matrix.empty() || matrix[0].empty()) {
		return false;
	}
	if (target < matrix[0][0] || target > matrix.back().back()) return false;

	int top = 0;
	int bottom = matrix.size() - 1;
	int row = 0;
	while (top + 1 < bottom) {
		int mid = (bottom - top) / 2 + top;
		if (matrix[mid][0] > target) {
			bottom = mid - 1;
		}
		else if (matrix[mid][0] < target) {
			top = mid;
		}
		else {
			row = mid;
			return true;
		}
	}

	if (matrix[bottom][0] > target) {
		row = top;
	}
	else {
		row = bottom;
	}

	int left = 0;
	int right = matrix[row].size() - 1;

	while (left + 1 < right) {
		int mid = (right - left) / 2 + left;
		if (matrix[row][mid] > target) {
			right = mid - 1;
		}
		else if (matrix[row][mid] < target) {
			left = mid + 1;
		}
		else {
			return true;
		}
	}

	if (matrix[row][left] == target || matrix[row][right] == target) {
		return true;
	}
	else {
		return false;
	}
}

/*
# 75. Sort Colors
Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note: You are not suppose to use the library's sort function for this problem.

Example:

Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
Follow up:

A rather straight forward solution is a two-pass algorithm using counting sort.
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.
Could you come up with a one-pass algorithm using only constant space?
*/

//Use any sort algorithm(such as counting sort)
//Or use 2 pointers method below, notice --i in nums[i] == 2 case;

void sortColors(vector<int>& nums) {
	int left = 0;
	int right = nums.size() - 1;

	for (int i = 0; i <= right; ++i) {
		if (nums[i] == 0) {
			swap(nums[i], nums[left]);
			++left;
		}
		else if (nums[i] == 2) {
			swap(nums[i], nums[right]);
			--i;
			--right;
		}
	}
}

/*
# 76. Minimum Window Substring
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

Example:

Input: S = "ADOBECODEBANC", T = "ABC"
Output: "BANC"
Note:

If there is no such window in S that covers all characters in T, return the empty string "".
If there is such window, you are guaranteed that there will always be only one unique minimum window in S.
*/

//Sliding window. step1: traverse target string to update the hashMap(key is the char, value is the count).
//step 2: starting to traverse the string s, minus 1 for the current char's value in hashMap, if the value is still greater than OR EQUALS TO zero, that means it is one char in target(not dup). Then currentSub++.
//step 3: when currentSub equals to the size of s, that means we get a qualified substring. Then start to shrink the left: traverse from the left, add 1 for the current char's value in hashMap, if the value is greater than 0, than means it is a necessary char, we cannot shrink any more. Not update the result.
string minWindow(string s, string t) {

	unordered_map<char, int> charCounter;
	
	//NOTICE how to initial these ints
	int currentSub = 0;
	int left = 0;
	int right = 0;
	string result;
	int curMinLen = INT_MAX;
	for (int i = 0; i < t.size(); ++i) {
		++charCounter[t[i]];
	}

	for (int i = 0; i < s.size(); ++i) {
		--charCounter[s[i]];
		if (charCounter[s[i]] >= 0) {
			++currentSub;
		}

		//shrink left
		while (currentSub == t.size()) {

			++charCounter[s[left]];
			if (charCounter[s[left]] > 0) {
				--currentSub;
			}
			if ((i - left + 1) < curMinLen) {
				result = s.substr(left, i - left + 1);
				curMinLen = i - left + 1;
			}

			++left;
		}
	}

	return result;
}

//version 2
string minWindow(string s, string t) {
	if (s.size() < t.size() || s.empty()) {
		return "";
	}

	int left = 0;
	int right = 0;
	int count = 0;
	unordered_map<char, int> charMap;
	string result = "";

	for (int i = 0; i < t.size(); ++i) {
		++charMap[t[i]];
	}

	while (right < s.size()) {
		if (charMap.count(s[right])) {
			--charMap[s[right]];
			if (charMap[s[right]] >= 0) {
				++count;
			}
		}

		while (count == t.size()) {
			if (charMap.count(s[left])) {
				++charMap[s[left]];
				if (charMap[s[left]] > 0) {
					--count;
					if (result.empty() || result.size() > right - left + 1) {
						result = s.substr(left, right - left + 1);
					}
				}
			}
			++left;
		}
		++right;
	}

	return result;

}

/*
# 77. Combinations
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

Example:

Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
*/
//Recursive combination method.
//Method 2: C(n, k) = C(n-1, k-1) + C(n-1, k)
vector<vector<int>> combine(int n, int k) {

	if (n == 0 || k == 0) {
		return {};
	}

	vector<vector<int>> result;
	vector<int> curCom;
	int start = 0;
	vector<int> nums;
	for (int i = 1; i <= n; ++i) {
		nums.push_back(i);
	}
	CombineRec(nums, curCom, result, k, start);
	return result;
}

void CombineRec(vector<int>& nums, vector<int>& cur, vector<vector<int>>& res, int size, int start) {
	if (cur.size() == size) {
		res.push_back(cur);
	}

	for (int i = start; i < nums.size(); ++i) {
		cur.push_back(nums[i]);
		CombineRec(nums, cur, res, size, i + 1);
		cur.pop_back();
	}
}

class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        if (k > n || k < 0) return {};
        if (k == 0) return {{}};
        vector<vector<int>> res = combine(n - 1, k - 1);
        for (auto &a : res) a.push_back(n);
        for (auto &a : combine(n - 1, k)) res.push_back(a);
        return res;
    }
};

/*
# 78. Subsets
Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
*/

vector<vector<int>> subsets(vector<int>& nums) {
	if (nums.empty()) {
		return {};
	}

	vector<vector<int>> result;
	vector<int> curSet;

	for (int i = 0; i <= nums.size(); ++i) {
		CombineRec(nums, curSet, result, i, 0);
	}

	return result;
}
void CombineRec(vector<int>& nums, vector<int>& cur, vector<vector<int>>& res, int size, int start) {
	if (cur.size() == size) {
		res.push_back(cur);
	}

	for (int i = start; i < nums.size(); ++i) {
		cur.push_back(nums[i]);
		CombineRec(nums, cur, res, size, i + 1);
		cur.pop_back();
	}
}

/*
# 79. Word Search
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
*/

//Use a matrix to store if a position is visited. 
bool exist(vector<vector<char>>& board, string word) {

	if (word.empty()) {
		return true;
	}
	else if (board.empty() || board[0].empty()) {
		return false;
	}
	vector<vector<int>> vb(board.size(), vector<int>(board[0].size(), 0));
	for (int i = 0; i < board.size(); ++i) {
		for (int j = 0; j < board[0].size(); ++j) {
			if (recSearch(i, j, board, vb, word)) {
				return true;
			}
		}
	}
	return false;
}

bool recSearch(int row, int col, vector<vector<char>>& board, vector<vector<int>> visBit, string word) {
	
	//Notice this should be in front.
	if (word.empty()) {
		return true;
	}

	if (row >= board.size() || col >= board[0].size() || visBit[row][col] == 1) {
		return false;
	}

	visBit[row][col] = 1;

	if (board[row][col] == word[0]) {
		string newWord = word.substr(1);
		//bool curRes = recSearch(row - 1, col, );
		//return
		if (recSearch(row - 1, col, board, visBit, newWord)) {
			return true;
		}
		else if (recSearch(row, col - 1, board, visBit, newWord)) {
			return true;
		}
		else if (recSearch(row, col + 1, board, visBit, newWord)) {
			return true;
		}
		else if (recSearch(row + 1, col, board, visBit, newWord)) {
			return true;
		}
		else {
			return false;
		}
	}
	else {
		return false;
	}
}

/*
# 80. Remove Duplicates from Sorted Array II
Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn't matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
*/

//when find nums[i] == nums[i + 1], move i to i+1(in order to remain two equaling nums), then use a while loop to check and remove following
int removeDuplicates(vector<int>& nums) {
	if (nums.size() <= 1) {
		return nums.size();
	}

	for (int i = 0; i < nums.size(); ++i) {
		if (i + 1 < nums.size() && nums[i] == nums[i + 1]) {
			++i;
			while (i + 1< nums.size() && nums[i] == nums[i + 1]) {
				nums.erase(nums.begin() + i + 1);
			}
		}
	}
	return nums.size();
}

/*
# 81. Search in Rotated Sorted Array II
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).

You are given a target value to search. If found in the array return true, otherwise return false.

Example 1:

Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Example 2:

Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
Follow up:

This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.
Would this affect the run-time complexity? How and why?
*/

//Notice there might be dup nums(such as [1,3,1,1] or [3,1,1,1]), when nums[mid] == nums[right] we do --right until they does not equal.
bool search(vector<int>& nums, int target) {

	if (nums.empty()) {
		return false;
	}

	int left = 0;
	int right = nums.size() - 1;

	while (left + 1 < right) {
		int mid = (right - left) / 2 + left;
		if (nums[mid] > nums[right]) {
			if (target == nums[left] || target == nums[mid]) {
				return true;
			}
			else if (target > nums[left] && target < nums[mid]) {
				right = mid - 1;
			}
			else {
				left = mid + 1;
			}
		}
		else if (nums[mid] < nums[right]) {
			if (target == nums[right] || target == nums[mid]) {
				return true;
			}
			else if (target > nums[mid] && target < nums[right]) {
				left = mid + 1;
			}
			else {
				right = mid - 1;
			}
		}
		else if (nums[left] == target || nums[mid] == target) {
			return true;
		}
		else {
			while (left + 1 < right && nums[mid] == nums[right]) {
				--right;
			}
		}
	}
	if (target == nums[left] || target == nums[right]) {
		return true;
	}
	else {
		return false;
	}
}

/*
# 82. Remove Duplicates from Sorted List II
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

Example 1:

Input: 1->2->3->3->4->4->5
Output: 1->2->5
Example 2:

Input: 1->1->1->2->3
Output: 2->3
*/
//Need a dummyhead and a cur pointer. Head is always a pre pointer. if next two nodes are equal, use cur to check followings untial an unequal node(cur->next). Then connect head->next and cur->next;
ListNode* deleteDuplicates(ListNode* head) {
	ListNode dummyHead(0);
	dummyHead.next = head;
	head = &dummyHead;

	while (head->next && head->next->next) {
		if (head->next->val == head->next->next->val) {
			ListNode* cur = head->next->next;
			while (cur->next && cur->next->val == head->next->val) {
				cur = cur->next;
			}
			head->next = cur->next;
		}
		else {
			head = head->next;
		}
	}

	return dummyHead.next;
}

/*
# 84. Largest Rectangle in Histogram
Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
Example:

Input: [2,1,5,6,2,3]
Output: 10
*/

//We can only update result when we meet a "peak": traverse in reverse dir and update result.
int largestRectangleArea(vector<int>& heights) {
	if (heights.empty()) {
		return 0;
	}
	else if (heights.size() == 1) {
		return heights[0];
	}

	int result = 0;

	for (int i = 0; i < heights.size(); ++i) {
		if (i + 1 < heights.size() && heights[i] <= heights[i + 1]) {
			continue;
		}

		int curLow = heights[i];
		for (int j = i; j >= 0; --j) {
			curLow = min(curLow, heights[j]);
			int curArea = (i - j + 1) * curLow;
			if (curArea > result) {
				result = curArea;
			}
		}

	}

	return result;
}

/*
# 85. Maximal Rectangle
Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

Example:

Input:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
Output: 6
*/

//Take use of the function in #84. Each row and above in the matrix is a column chart. Create a new vector that contains all charts converted from matrix.
int maximalRectangle(vector<vector<char>>& matrix) {
	if (matrix.empty() || matrix[0].empty()) {
		return 0;
	}
	int result = 0;
	vector<vector<int>> colSet(matrix.size(), vector<int>(matrix[0].size(), 0));

	//initial the first line
	for (int i = 0; i < colSet[0].size(); ++i) {
		if (matrix[0][i] == '0') {
			colSet[0][i] = 0;
		}
		else {
			colSet[0][i] = 1;
		}
	}

	for (int i = 1; i < matrix.size(); ++i) {
		for (int j = 0; j < matrix[0].size(); ++j) {
			if (matrix[i][j] == '0') {
				colSet[i][j] = 0;
			}
			else {
				colSet[i][j] = colSet[i - 1][j] + 1;
			}
		}
		//result = maxRect(colSet[i]);
	}
	for (int i = 0; i < colSet.size(); ++i) {
		result = max(result, maxRect(colSet[i]));
	}
	return result;
}

int maxRect(vector<int>& heights) {
	int result = 0;
	for (int i = 0; i < heights.size(); ++i) {
		if (i + 1 < heights.size() && heights[i] < heights[i + 1]) {
			continue;
		}

		int minLow = heights[i];
		int curArea = heights[i];
		for (int j = i; j >= 0; --j) {
			minLow = min(minLow, heights[j]);
			curArea = (i - j + 1) * minLow;
			if (result < curArea) {
				result = curArea;
			}
		}
	}
	return result;
}

/*
# 86. Partition List
Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.

Example:

Input: head = 1->4->3->2->5->2, x = 3
Output: 1->2->2->4->3->5
*/

//Create a new list to store the nodes whose vals are greater than or equal to x. Then just connect two links.
//Method 2 : Find the first node whose val >= x. Then continue traversing and put the node whose vals < x to the front of that "first" node.
ListNode* partition(ListNode* head, int x) {
	if (!head || !head->next) {
		return head;
	}
	ListNode newDummyHead(-1);
	ListNode* newHead = &newDummyHead;
	ListNode dummyHead(-1);
	dummyHead.next = head;
	head = &dummyHead;

	while (head->next) {
		if (head->next->val >= x) {
			ListNode* newNode = new ListNode(head->next->val);
			newHead->next = newNode;
			newHead = newHead->next;

			head->next = head->next->next;
		}
		else {
			head = head->next;
		}
	}
	head->next = newDummyHead.next;
	return dummyHead.next;
}

/*
# 87. Scramble String
Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

Below is one possible representation of s1 = "great":

    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
To scramble the string, we may choose any non-leaf node and swap its two children.

For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".

    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
We say that "rgeat" is a scrambled string of "great".

Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".

    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
We say that "rgtae" is a scrambled string of "great".

Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.

Example 1:

Input: s1 = "great", s2 = "rgeat"
Output: true
Example 2:

Input: s1 = "abcde", s2 = "caebd"
Output: false
*/

//Pre-check: length; chars(sort and then compare); rec exit entry
//Notice to check 1.(first i elements in s1 and first i elements in s1; last len - i elements in s1 and last len - i elements in s2) 2.(first i elements in s1 and last i elements in s1; last len - i elements in s1 and first len - i elements in s2)
bool isScramble(string s1, string s2) {
	int len1 = s1.size();
	int len2 = s2.size();
	if (len1 != len2) {
		return false;
	}
	else if (len1 == 1) {
		return s1 == s2;
	}
	string str1 = s1, str2 = s2;
	sort(str1.begin(), str1.end());
	sort(str2.begin(), str2.end());
	if (str1 != str2) return false;
	for (int i = 1; i < len1; ++i) {
		string s11 = s1.substr(0, i);
		string s12 = s1.substr(i);
		string s21 = s2.substr(0, i);
		string s22 = s2.substr(i);
		if (isScramble(s11, s21) && isScramble(s12, s22)) {
			return true;
		}

		s21 = s2.substr(len1 - i);
		s22 = s2.substr(0, len1 - i);
		if (isScramble(s11, s21) && isScramble(s12, s22)) {
			return true;
		}
	}
	return false;
}

/*
# 88. Merge Sorted Array
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:

The number of elements initialized in nums1 and nums2 are m and n respectively.
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.
Example:

Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
*/
//Notice how to use pop_back and insert
//Remember to handle edge cases that m == 0;
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
	if (m == 0) {
		nums1 = nums2;
	}
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < m; ++j) {
			if (nums2[i] <= nums1[j]) {
				nums1.pop_back();
				nums1.insert(nums1.begin() + j, nums2[i]);
				++m;
				break;
			}
			else if (j == m - 1) {
				nums1.pop_back();
				nums1.insert(nums1.begin() + m, nums2[i]);
				++m;
				break;
			}
		}
	}
}

/*
# 89. Gray Code
The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

Example 1:

Input: 2
Output: [0,1,3,2]
Explanation:
00 - 0
01 - 1
11 - 3
10 - 2

For a given n, a gray code sequence may not be uniquely defined.
For example, [0,2,3,1] is also a valid gray code sequence.

00 - 0
10 - 2
11 - 3
01 - 1
Example 2:

Input: 0
Output: [0]
Explanation: We define the gray code sequence to begin with 0.
             A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.
             Therefore, for n = 0 the gray code sequence is [0].
*/

//Notice how to convert num into its gray code.
vector<int> grayCode(int n) {
	vector<int> result;
	for (int i = 0; i < pow(2, n); ++i) {
		result.push_back((i >> 1) ^ i);
	}
	return result;
}

/*
# 91. Decode Ways
A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -> 1
'B' -> 2
...
'Z' -> 26
Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:

Input: "12"
Output: 2
Explanation: It could be decoded as "AB" (1 2) or "L" (12).
Example 2:

Input: "226"
Output: 3
Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
*/

//Use dp and fibo. Notice the initialization of dp[0] and dp[1]
int numDecodings(string s) {

	vector<int> decCount(s.size(), 0);

	if (s.empty()) {
		return 0;
	}
	
	//initial dp[0]
	if (s[0] == '0') {
		return 0;
	}
	else {
		decCount[0] = 1;
	}
	
	//initial dp[1]
	if (s[0] - '0' <= 0) {

	}
	else if (s[0] - '0' == 1) {
		if (s[1] == '0') {
			decCount[1] = 1;
		}
		else {
			decCount[1] = 2;
		}

	}
	else if (s[0] - '0' == 2) {
		if (s[1] - '0' > 6 || s[1] == '0') {
			decCount[1] = 1;
		}
		else {
			decCount[1] = 2;
		}
	}
	else {
		if (s[1] == '0') {
			decCount[1] = 0;
		}
		else {
			decCount[1] = 1;
		}
	}

	int len = s.size();
	//int result = 0;
	
	//Fibonacci
	for (int i = 2; i <s.size(); ++i) {
		int curRes = 0;
		if (s[i] == '0') {
			curRes = 0;
		}
		else {
			curRes += decCount[i - 1];
		}

		if (s[i - 1] - '0' == 1) {
			curRes += decCount[i - 2];
		}
		else if (s[i - 1] - '0' == 2 && s[i] - '0' <= 6) {
			curRes += decCount[i - 2];
		}
		decCount[i] = curRes;
	}

	return decCount[len - 1];
}

/*
# 93. Restore IP Addresses
Given a string containing only digits, restore it by returning all possible valid IP address combinations.

Example:

Input: "25525511135"
Output: ["255.255.11.135", "255.255.111.35"]
*/

//Use recursion. Notice Need to ask if 0 is valid and how to use substr.
vector<string> restoreIpAddresses(string s) {
	vector<vector<string>> resSet;
	vector<string> cur;
	vector<string> result;
	IpRecResolver(s, cur, resSet);

	for (int i = 0; i < resSet.size(); ++i) {
		result.push_back("");
		result[i].append(resSet[i][0]);
		result[i].append(".");
		result[i].append(resSet[i][1]);
		result[i].append(".");
		result[i].append(resSet[i][2]);
		result[i].append(".");
		result[i].append(resSet[i][3]);
	}

	return result;
}

void IpRecResolver(string input, vector<string>& cur, vector<vector<string>>& result) {
	if (cur.size() == 4) {
		if (input.empty()) {
			result.push_back(cur);
		}
		else {
			return;
		}
	}

	if (input.empty()) {
		return;
	}

	//Need to ask if 0 is valid
	/*cur.push_back("0");
	IpRecResolver(input, cur, result);
	cur.pop_back();*/

	cur.push_back(input.substr(0, 1));
	IpRecResolver(input.substr(1), cur, result);
	cur.pop_back();

	if (input[0] != '0' && input.size() >= 2) {
		cur.push_back(input.substr(0, 2));
		IpRecResolver(input.substr(2), cur, result);
		cur.pop_back();

		if (input.size() >= 3) {
			string three = input.substr(0, 3);
			if (atoi(three.c_str()) <= 255) {
				cur.push_back(three);
				IpRecResolver(input.substr(3), cur, result);
				cur.pop_back();
			}
		}
	}
}

/*
# 94. Binary Tree Inorder Traversal
Given a binary tree, return the inorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
Follow up: Recursive solution is trivial, could you do it iteratively?
*/
//Need to remember non-recursive method
vector<int> inorderTraversal(TreeNode* root) {
        if(!root){
            return {};
        }
        vector<int> result;
        stack<TreeNode*> treeStack;
        //treeStack.push(root);
        while(root || !treeStack.empty()){
            
            //Add all left nodes firstly
            while(root){
                treeStack.push(root);
                root = root->left;
            }
            
            //handle the node
            root = treeStack.top();
            treeStack.pop();
            //treeStack.push(root);
            result.push_back(root->val);
            
            //Handle right branch
            root = root->right;
        }
        /*
        DC method
        vector<int> left = inorderTraversal(root->left);
        result.insert(result.end(), left.begin(), left.end());
        result.push_back(root->val);        
        vector<int> right = inorderTraversal(root->right);        
        result.insert(result.end(), right.begin(), right.end());*/
        return result;
    }

/*
# 145. Binary Tree Postorder Traversal
Given a binary tree, return the postorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [3,2,1]
Follow up: Recursive solution is trivial, could you do it iteratively?
*/

//Use stack.
vector<int> postorderTraversal(TreeNode* root) {
	if (!root) {
		return {};
	}
	vector<int> result;
	stack<TreeNode*> nodesStack;

	//Notice the initial value can't be NULL
	TreeNode* lastNode = root;
	nodesStack.push(root);
	
	while (!nodesStack.empty()) {

		TreeNode* curNode = nodesStack.top();
		
		//Check if it is a leaf node, or, left and right branches are all done.
		if ((!curNode->left && !curNode->right) || lastNode == curNode->left || lastNode == curNode->right) {
			result.push_back(curNode->val);
			nodesStack.pop();
			lastNode = curNode;
		}
		else {
		//Should check both !!
			if (curNode->right) {
				nodesStack.push(curNode->right);
			}
			if (curNode->left) {
				nodesStack.push(curNode->left);
			}
		}
	}
	return result;
}

/*
# 144. Binary Tree Preorder Traversal
Given a binary tree, return the preorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
Follow up: Recursive solution is trivial, could you do it iteratively?
*/

//Always remember to check null root.
vector<int> preorderTraversal(TreeNode* root) {
	if (!root) {
		return {};
	}
	vector<int> result;
	TreeNode* curNode = root;
	stack<TreeNode*> nodesStack;
	nodesStack.push(root);
	while (!nodesStack.empty()) {
		curNode = nodesStack.top();
		nodesStack.pop();
		result.push_back(curNode->val);
		if (curNode->right) {
			nodesStack.push(curNode->right);
		}
		if (curNode->left) {
			nodesStack.push(curNode->left);
		}
	}
	return result;
}

/*
# 95. Unique Binary Search Trees II
Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n.

Example:

Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST's shown below:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
*/

//Use recursion. Notice features of BST. Traverse from num 1-n and use each num as root node, use nums in the left to construct all possible left branches, the same as all right branches, then combine left and right branches.
//Notice NULL is also a valid branch 
vector<TreeNode*> generateTrees(int n) {
	if (n == 0) {
		return {};
	}
	return BSTgenerator(1, n);
}

vector<TreeNode*> BSTgenerator(int start, int end) {
	if (start > end) {
		return { NULL };
	}

	vector<TreeNode*> treeSet;

	for (int i = start; i <= end; ++i) {
		vector<TreeNode*> leftTrees = BSTgenerator(start, i - 1);
		vector<TreeNode*> rightTrees = BSTgenerator(i + 1, end);
		for (int m = 0; m < leftTrees.size(); ++m) {
			for (int n = 0; n < rightTrees.size(); ++n) {
				TreeNode* newNode = new TreeNode(i);
				newNode->left = leftTrees[m];
				newNode->right = rightTrees[n];
				treeSet.push_back(newNode);
			}
		}
	}
	return treeSet;
}

/*
# 96. Unique Binary Search Trees
Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?

Example:

Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST's:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
*/
//Use Catalan num.
int numTrees(int n) {
	vector<int> catalanNum(n + 1, 0);

	catalanNum[0] = 1;
	catalanNum[1] = 1;

	for (int i = 2; i < n + 1; ++i) {
		for (int j = 0; j < i; ++j) {
		// -1 here means minus the root node.
			catalanNum[i] += catalanNum[j] * catalanNum[i - 1 - j];
		}
	}
	return catalanNum[n];
}

/*
# 97. Interleaving String
Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

Example 1:

Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
Output: true
Example 2:

Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
Output: false
*/
//Use dp. dp[i][j] means the first i+j chars in s3 is formed by the interleaving of the first i chars in s1 and the first j chars in s2.
//when calc dp[i][j], there are 2 cases that it can be true: 1. s1[i - 1] == s3[i+j-1] and dp[i-1][j] == true 2. s2[j-1] == s3[i+j-1]  and dp[i][j - 1] == true
bool isInterleave(string s1, string s2, string s3) {
	if (s1.size() + s2.size() != s3.size()) {
		return false;
	}
	else if (s1.empty()) {
		return s2 == s3;
	}
	else if (s2.empty()) {
		return s1 == s3;
	}
	vector<vector<bool>> interTable(s1.size() + 1, vector<bool>(s2.size() + 1, false));
	interTable[0][0] = true;
	for (int i = 1; i < interTable.size(); ++i) {
		interTable[i][0] = interTable[i - 1][0] && (s1[i - 1] == s3[i - 1]);
	}
	for (int i = 1; i < interTable.size(); ++i) {
		interTable[0][i] = interTable[0][i - 1] && (s2[i - 1] == s3[i - 1]);
	}

	for (int i = 1; i < interTable.size(); ++i) {
		for (int j = 1; j < interTable[0].size(); ++j) {
			interTable[i][j] = (interTable[i - 1][j] && (s1[i - 1] == s3[i - 1 + j])) || (interTable[i][j - 1] && (s2[j - 1] == s3[j - 1 + i]));
		}
	}

	return interTable[s1.size()][s2.size()];
}

//Recursive method that is TLE
bool isInterleave(string s1, string s2, string s3) {
	int cur1 = 0;
	int cur2 = 0;
	//int cur3 = 0;
	if (s1.size() + s2.size() != s3.size()) {
		return false;
	}
	else if (s1.empty()) {
		return s2 == s3;
	}
	else if (s2.empty()) {
		return s1 == s3;
	}

	for (int i = 0; i < s3.size(); ++i) {
		if (s1[cur1] == s2[cur2]) {
			if (s1[cur1] == s3[i]) {
				return isInterleave(s1.substr(cur1 + 1), s2.substr(cur2), s3.substr(i + 1)) || isInterleave(s1.substr(cur1), s2.substr(cur2 + 1), s3.substr(i + 1));
			}
			else {
				return false;
			}
		}
		else if (s1[cur1] == s3[i]) {
			++cur1;
		}
		else if (s2[cur2] == s3[i]) {
			++cur2;
		}
		else {
			return false;
		}
	}
	return true;
}

/*
# 98. Validate Binary Search Tree
Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
Example 1:

Input:
    2
   / \
  1   3
Output: true
Example 2:

    5
   / \
  1   4
     / \
    3   6
Output: false
Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value
             is 5 but its right child's value is 4.
*/
//method1: use features of BST. Notice "ALL" in BST features.
//method2: use inorver traverse.
bool isValidBST(TreeNode* root) {
	return ValidateBST(root, LONG_MIN, LONG_MAX);
}

bool ValidateBST(TreeNode* root, long min, long max) {
	if (!root) {
		return true;
	}

	if (root->val >= max || root->val <= min) {
		return false;
	}
	else {
		return ValidateBST(root->left, min, root->val) && ValidateBST(root->right, root->val, max);
	}
}

/*
# 99. Recover Binary Search Tree
Two elements of a binary search tree (BST) are swapped by mistake.

Recover the tree without changing its structure.

Example 1:

Input: [1,3,null,null,2]

   1
  /
 3
  \
   2

Output: [3,1,null,null,2]

   3
  /
 1
  \
   2
Example 2:

Input: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

Output: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3
Follow up:

A solution using O(n) space is pretty straight forward.
Could you devise a constant space solution?
*/

//Method1: use inorder traverse. then sort all vals, then assign sorted vals to the tree.
//Method2: Morris traverse.
void recoverTree(TreeNode* root) {
	vector<TreeNode*> treeNodes;
	vector<int> vals;
	InorderTra(treeNodes, vals, root);
	sort(vals.begin(), vals.end());
	for (int i = 0; i < vals.size(); ++i) {
		treeNodes[i]->val = vals[i];
	}
}

void InorderTra(vector<TreeNode*>& nodes, vector<int>& vals, TreeNode* root) {
	if (!root) {
		return;
	}
	InorderTra(nodes, vals, root->left);
	nodes.push_back(root);
	vals.push_back(root->val);
	InorderTra(nodes, vals, root->right);
}

/*
# 100. Same Tree
Given two binary trees, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical and the nodes have the same value.

Example 1:

Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true
Example 2:

Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false
Example 3:

Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false
*/
//DFS
bool isSameTree(TreeNode* p, TreeNode* q) {
	if (!p && !q) {
		return true;
	}
	if ((p && !q) || (!p && q) || (p->val != q->val)) {
		return false;
	}
	return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}

/*
# 101. Symmetric Tree
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following [1,2,2,null,3,null,3] is not:
    1
   / \
  2   2
   \   \
   3    3
Note:
Bonus points if you could solve it both recursively and iteratively.
*/

//use recursion that use a new function to check if two trees are symmetric: check if val equals and if twoTreesSym(t1->left, t2->right) && twoTreesSym(t1->right, t2->left)
//Need to try iterative method.
bool isSymmetric(TreeNode* root) {
	if (!root) {
		return true;
	}
	else {
		return twoTreesSym(root->left, root->right);
	}
}

bool twoTreesSym(TreeNode* t1, TreeNode* t2) {
	if (!t1 && !t2) {
		return true;
	}
	else if ((!t1 && t2) || (t1 && !t2) || (t1->val != t2->val)) {
		return false;
	}
	else {
		return twoTreesSym(t1->left, t2->right) && twoTreesSym(t1->right, t2->left);
	}
}

/*
# 102. Binary Tree Level Order Traversal
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
*/

//Use a queue to store nodes. Use a count=queue.size to store how many nodes in cur level then use a for loop to traverse and pop all nodes.
vector<vector<int>> levelOrder(TreeNode* root) {
	if (!root) {
		return {};
	}
	vector<vector<int>> result;

	queue<TreeNode*> nodes;
	int count = 1;
	nodes.push(root);

	while (!nodes.empty()) {
		vector<int> curLevel;
		count = nodes.size();
		for (int i = 0; i < count; ++i) {
			if (!nodes.empty()) {
				TreeNode* curNode = nodes.front();
				curLevel.push_back(curNode->val);
				if (curNode->left) {
					nodes.push(curNode->left);
				}
				if (curNode->right) {
					nodes.push(curNode->right);
				}
				nodes.pop();
			}
		}
		result.push_back(curLevel);
		count *= 2;
	}
	return result;
}

/*
# 103. Binary Tree Zigzag Level Order Traversal
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
*/
//Use a bool to control order of left/right, use a vector to store next level nodes, push them into stack after all nodes in current level are poped.
vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
	if (!root) {
		return {};
	}
	vector<vector<int>> result;
	stack<TreeNode*> nodes;
	queue<TreeNode*> nodesq;
	bool reverse = false;
	nodes.push(root);
	while (!nodes.empty()) {
		int size = nodes.size();
		vector<int> level;
		vector<TreeNode*> nextLevel;
		for (int i = 0; i < size; ++i) {
			TreeNode* curNode = nodes.top();
			level.push_back(curNode->val);
			nodes.pop();
			if (!reverse) {
				if (curNode->left) {
					nextLevel.push_back(curNode->left);
				}
				if (curNode->right) {
					nextLevel.push_back(curNode->right);
				}
			}
			else {
				if (curNode->right) {
					nextLevel.push_back(curNode->right);
				}
				if (curNode->left) {
					nextLevel.push_back(curNode->left);
				}
			}
		}
		for (int i = 0; i < nextLevel.size(); ++i) {
			nodes.push(nextLevel[i]);
		}
		reverse = !reverse;
		result.push_back(level);
	}
	return result;
}

/*
# 104. Maximum Depth of Binary Tree
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its depth = 3.
*/
//Use DFS
int maxDepth(TreeNode* root) {
	if (!root) {
		return 0;
	}
	int result;

	return max(maxDepth(root->left), maxDepth(root->right)) + 1;

}

/*
# 105. Construct Binary Tree from Preorder and Inorder Traversal
Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given

preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7
*/

//the first element of preorder is the root. Then check the index of root in inorder, then we can know the range of left and right nodes.
//Notice the borders.
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
	if (preorder.empty() || inorder.empty()) {
		return NULL;
	}
	return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
}
TreeNode* buildTree(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd) {
	if (preStart > preEnd || inStart > inEnd) {
		return NULL;
	}
	int rootVal = preorder[preStart];
	TreeNode* root = new TreeNode(rootVal);
	int rootInIndex = -1;
	for (int i = inStart; i <= inEnd; ++i) {
		if (inorder[i] == rootVal) {
			rootInIndex = i;
			break;
		}
	}

	root->left = buildTree(preorder, preStart + 1, preStart + 1 + (rootInIndex - inStart) - 1, inorder, inStart, rootInIndex - 1);
	root->right = buildTree(preorder, preStart + 1 + (rootInIndex - inStart), preEnd, inorder, rootInIndex + 1, inEnd);
	return root;
}

/*
# 107. Binary Tree Level Order Traversal II
Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
*/
//Just insert each level at the beginning.
vector<vector<int>> levelOrderBottom(TreeNode* root) {
	if (!root) {
		return {};
	}
	vector<vector<int>> result;

	queue<TreeNode*> nodes;
	int count = 1;
	nodes.push(root);

	while (!nodes.empty()) {
		vector<int> curLevel;
		count = nodes.size();
		for (int i = 0; i < count; ++i) {
			if (!nodes.empty()) {
				TreeNode* curNode = nodes.front();
				curLevel.push_back(curNode->val);
				if (curNode->left) {
					nodes.push(curNode->left);
				}
				if (curNode->right) {
					nodes.push(curNode->right);
				}
				nodes.pop();
			}
		}
		result.insert(result.begin(), curLevel);
		count *= 2;
	}
	return result;
}

/*
# 108. Convert Sorted Array to Binary Search Tree
Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:

Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
*/

//Use the mid as root, then use left/right part to build left/right branch.
TreeNode* sortedArrayToBST(vector<int>& nums) {
	if (nums.empty()) {
		return NULL;
	}
	return buildBST(nums, 0, nums.size() - 1);
}

TreeNode* buildBST(vector<int>& nums, int start, int end) {
	if (start > end) {
		return NULL;
	}
	int mid = (end - start) / 2 + start;
	TreeNode* root = new TreeNode(nums[mid]);

	root->left = buildBST(nums, start, mid - 1);
	root->right = buildBST(nums, mid + 1, end);
	return root;
}

/*
# 109. Convert Sorted List to Binary Search Tree
Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:

Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
*/
//Use slow&fast pointer to find the mid node, use a pre pointer to point to previous node of mid node.
//Notice the order to cut the list into two lists !! 
//Notice how to handle head when slow == head !! (Check if slow equals head firstly then move slow and cut.)
TreeNode* sortedListToBST(ListNode* head) {
	if (!head) {
		return NULL;
	}
	ListNode* slow = head;
	ListNode* fast = head;
	ListNode* pre = slow;
	while (fast->next && fast->next->next) {
		pre = slow;
		slow = slow->next;
		fast = fast->next->next;
	}

	TreeNode* root = new TreeNode(slow->val);
	if (slow == head) {
		head = NULL;
	}
	//Check if slow equals head firstly then move slow and cut.
	slow = slow->next;
	pre->next = NULL;

	root->left = sortedListToBST(head);
	root->right = sortedListToBST(slow);
	return root;
}

/*
# 110. Balanced Binary Tree
Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example 1:

Given the following tree [3,9,20,null,null,15,7]:

    3
   / \
  9  20
    /  \
   15   7
Return true.

Example 2:

Given the following tree [1,2,2,3,3,null,null,4,4]:

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
Return false.
*/

//Use definition.
//Method 2 is to improve eff that if any branch is not balanced, return -1 instead of continuing calc depth
bool isBalanced(TreeNode* root) {
	if (!root) {
		return true;
	}

	return abs(maxDepth(root->left) - maxDepth(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);
}

int maxDepth(TreeNode* root) {
	if (!root) {
		return 0;
	}
	return max(maxDepth(root->left), maxDepth(root->right)) + 1;
}

//Method2
bool isBalanced(TreeNode *root) {
        if (checkDepth(root) == -1) return false;
        else return true;
    }
    int checkDepth(TreeNode *root) {
        if (!root) return 0;
        int left = checkDepth(root->left);
        if (left == -1) return -1;
        int right = checkDepth(root->right);
        if (right == -1) return -1;
        int diff = abs(left - right);
        if (diff > 1) return -1;
        else return 1 + max(left, right);
    }
    
/*
# 111. Minimum Depth of Binary Tree
Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its minimum depth = 2.
*/

//Notice when any branch is null, the branch should not be counted at all(return 1+depth of non-null branch) !!!
int minDepth(TreeNode* root) {
	if (!root) {
		return 0;
	}
	if (!root->left && !root->right) {
		return 1;
	}
	else if (!root->left) {
		return minDepth(root->right) + 1;
	}
	else if (!root->right) {
		return minDepth(root->left) + 1;
	}
	else {
		return min(minDepth(root->left), minDepth(root->right)) + 1;
	}
}

/*
# 112. Path Sum
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
*/

//Notice the end point must be a lead node !!!
bool hasPathSum(TreeNode* root, int sum) {
	if (!root) {
		return false;
	}
	//Notice the end point must be a lead node !!!
	else if (root->val == sum && !root->left && !root->right) {
		return true;
	}
	else {
		return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);
	}
}

/*
# 113. Path Sum II
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
Return:

[
   [5,4,11,2],
   [5,8,4,5]
]
*/
//Notice back tracking !!
vector<vector<int>> pathSum(TreeNode* root, int sum) {
	vector<vector<int>> result;
	vector<int> curPath;
	hasPathSum(result, curPath, root, sum);
	return result;
}

void hasPathSum(vector<vector<int>>& result, vector<int>& curPath, TreeNode* root, int sum) {
	if (!root) {
		return;
	}
	curPath.push_back(root->val);
	if (root->val == sum && !root->left && !root->right) {
		result.push_back(curPath);
	}
	else {
		hasPathSum(result, curPath, root->left, sum - root->val);
		hasPathSum(result, curPath, root->right, sum - root->val);
	}
	curPath.pop_back();
}

/*
# 114. Flatten Binary Tree to Linked List
Given a binary tree, flatten it to a linked list in-place.

For example, given the following tree:

    1
   / \
  2   5
 / \   \
3   4   6
The flattened tree should look like:

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
*/

//Use DFS. Flatten left and right branch firstly. Then find the tail of left branch, connect root->right to the tail, then set the left branch to root->right, finally set root->left as NULL;
void flatten(TreeNode* root) {
	if (!root) {
		return;
	}

	flatten(root->left);
	flatten(root->right);
	if (root->left) {
		TreeNode* leftR = root->left;
		while (leftR->right) {
			leftR = leftR->right;
		}
		leftR->right = root->right;
		root->right = root->left;
		root->left = NULL;
	}
}

/*
# 115. Distinct Subsequences
Given a string S and a string T, count the number of distinct subsequences of S which equals T.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).

Example 1:

Input: S = "rabbbit", T = "rabbit"
Output: 3
Explanation:

As shown below, there are 3 ways you can generate "rabbit" from S.
(The caret symbol ^ means the chosen letters)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
Example 2:

Input: S = "babgbag", T = "bag"
Output: 5
Explanation:

As shown below, there are 5 ways you can generate "bag" from S.
(The caret symbol ^ means the chosen letters)

babgbag
^^ ^
babgbag
^^    ^
babgbag
^    ^^
babgbag
  ^  ^^
babgbag
    ^^^
*/

//Use dp. dp[i][j] represents the number of distinct subsequences of the first j letters in s that equals the first i letters in t.
//The formula is: dp[i][j] is at least dp[i][j - 1](s[j - 1] is not picked), if s[j - 1] == t[i - 1] then dp[i][j] += dp[i-1][j-1](s[j - 1] can be picked to cover t[i - 1]). 
int numDistinct(string s, string t) {
	if (t.empty()) {
		return 1;
	}
	else if (s.size() < t.size()) {
		return 0;
	}

	int lenS = s.size();
	int lenT = t.size();

	vector<vector<int>> caseTable(lenT + 1, vector<int>(lenS + 1, 0));
	caseTable[0][0] = 1;
	for (int i = 1; i < caseTable[0].size(); ++i) {
		caseTable[0][i] = 1;
	}
	for (int i = 1; i < caseTable.size(); ++i) {
		caseTable[i][0] = 0;
	}

	for (int i = 1; i < caseTable.size(); ++i) {
		for (int j = 1; j < caseTable[0].size(); ++j) {
			caseTable[i][j] = caseTable[i][j - 1];
			if (s[j - 1] == t[i - 1]) {
				caseTable[i][j] += caseTable[i - 1][j - 1];
			}
		}
	}
	return caseTable[lenT][lenS];
}

/*
# 116. Populating Next Right Pointers in Each Node
Given a binary tree

struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Note:

You may only use constant extra space.
Recursive approach is fine, implicit stack space does not count as extra space for this problem.
You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).
Example:

Given the following perfect binary tree,

     1
   /  \
  2    3
 / \  / \
4  5  6  7
After calling your function, the tree should look like:

     1 -> NULL
   /  \
  2 -> 3 -> NULL
 / \  / \
4->5->6->7 -> NULL
*/

//Use level traversal; notice how to handle root->right->next;
//Should also try iterative and O(1) method.
void connect(TreeLinkNode *root) {
	if (!root) {
		return;
	}

	if (root->left) {
		root->left->next = root->right;
	}
	if (root->right && root->next) {
		root->right->next = root->next->left;
	}
	connect(root->left);
	connect(root->right);
}

/*
# 117. Populating Next Right Pointers in Each Node II
Given a binary tree

struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Note:

You may only use constant extra space.
Recursive approach is fine, implicit stack space does not count as extra space for this problem.
Example:

Given the following binary tree,

     1
   /  \
  2    3
 / \    \
4   5    7
After calling your function, the tree should look like:

     1 -> NULL
   /  \
  2 -> 3 -> NULL
 / \    \
4-> 5 -> 7 -> NULL
*/
//Method1: Use level traversal (not constant space)
void connect(TreeLinkNode *root) {
	if (!root) {
		return;
	}

	queue<TreeLinkNode*> nodes;
	nodes.push(root);
	while (!nodes.empty()) {
		int size = nodes.size();
		for (int i = 0; i < size; ++i) {
			TreeLinkNode* curNode = nodes.front();
			nodes.pop();
			if (i != size - 1) {
				curNode->next = nodes.front();
			}

			if (curNode->left) {
				nodes.push(curNode->left);
			}
			if (curNode->right) {
				nodes.push(curNode->right);
			}
		}
	}
}

//Method2: use root to point to nodes in current level. Use cur to point to nodes in next level that need to connect.
//Use dummy to point to the first node in next level for transit root to next level when one level is finished.
void connect(TreeLinkNode *root) {
	if (!root) {
		return;
	}

	//Use the dummy pointer to point to the first node of next level
	TreeLinkNode* dummy = new TreeLinkNode(0);
	//Use cur to point to current node in next level that need to connect
	TreeLinkNode* cur;

	cur = dummy;
	while (root) {
		if (root->left) {
			cur->next = root->left;
			cur = cur->next;
		}
		if (root->right) {
			cur->next = root->right;
			cur = cur->next;
		}
		root = root->next;
		if (!root) {
			cur = dummy;
			root = dummy->next;
			//prevent infinite loop when root is a leaf node.
			dummy->next = NULL;
		}

	}
}

/*
# 118. Pascal's Triangle
Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.
In Pascal's triangle, each number is the sum of the two numbers directly above it.

Example:

Input: 5
Output:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
*/

//Notice how to initial vector!!!!!!
vector<vector<int>> generate(int numRows) {
	if (numRows == 0) {
		return {};
	}

	vector<vector<int>> result;
	result.push_back({ 1 });
	//Cannot access by index if it is not initialed.
	//result[0][0] = 1;
	for (int i = 1; i < numRows; ++i) {
		vector<int> curLevel(i + 1, 1);
		for (int j = 1; j < i; ++j) {
			curLevel[j] = result[i - 1][j - 1] + result[i - 1][j];
		}
		result.push_back(curLevel);
	}
	return result;
}

/*
# 119. Pascal's Triangle II
Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle.

Note that the row index starts from 0.
In Pascal's triangle, each number is the sum of the two numbers directly above it.

Example:

Input: 3
Output: [1,3,3,1]
Follow up:

Could you optimize your algorithm to use only O(k) extra space?
*/
//Accumulation(dp by row): Notice in Pascal's Triangle, a new row is calculated by previous row.
//So we can update the current row to next row by adding two adjacent elements: the new element in the same index is the sum of itself and it previous element.
//Notice the index.
vector<int> getRow(int rowIndex) {
	vector<int> result(rowIndex + 1, 0);
	result[0] = 1;

	for (int i = 1; i < rowIndex + 1; ++i) {
		for (int j = i; j >= 1; --j) {
			result[j] += result[j - 1];
		}
	}
	return result;
}

/*
# 121. Best Time to Buy and Sell Stock
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:

Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
Example 2:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
*/

//Traverse. Always update the buy price to the lowest so far. Update the profit at the same time.
int maxProfit(vector<int>& prices) {

	int result = 0;
	int buyPri = INT_MAX;
	for (int i = 0; i < prices.size(); ++i) {
		buyPri = min(buyPri, prices[i]);
		result = max(result, prices[i] - buyPri);
	}

	return result;
}

/*
# 122. Best Time to Buy and Sell Stock II
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:

Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Example 2:

Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
Example 3:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
*/
//Method1: sell when next price is lower and then buy at the lower price. Notice to check if need to sell in the tail price.
int maxProfit(vector<int>& prices) {

	if (prices.size() <= 1) {
		return 0;
	}

	int result = 0;
	int buyPri = prices[0];
	for (int i = 0; i < prices.size(); ++i) {
		if (i + 1 < prices.size() && prices[i] > prices[i + 1]) {
			result += prices[i] - buyPri;
			buyPri = prices[i + 1];
		}
		else if (i == prices.size() - 1 && prices[i] > buyPri) {
			result += prices[i] - buyPri;
		}
	}
	return result;
}

//Method2: sell when the price is higher than last price and add profit.
int maxProfit(vector<int>& prices) {
	int res = 0, n = prices.size();
	for (int i = 0; i < n - 1; ++i) {
		if (prices[i] < prices[i + 1]) {
			res += prices[i + 1] - prices[i];
		}
	}
	return res;
}

/*
# 123. Best Time to Buy and Sell Stock III
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:

Input: [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.
Example 2:

Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
Example 3:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
*/

/*
Explanation:
It's not difficult to get the DP recursive formula:
				//dp[k][i] is max of: 1.kth trade happens in i-1 days. don't trade on ith day 2. sell on ith day that was bought on jth day. Need to find the j that makes prices[i] - prices[j] + dp[k-1, j-1] is the smallest.
dp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j-1]), j=[0..i-1]
For k transactions, on i-th day,
if we don't trade then the profit is same as previous day dp[k, i-1];
and if we bought the share on j-th day where j=[0..i-1], then sell the share on i-th day then the profit is prices[i] - prices[j] + dp[k-1, j-1] .
Actually j can be i as well. When j is i, the one more extra item prices[i] - prices[j] + dp[k-1, j] = dp[k-1, i] looks like we just lose one chance of transaction.

I see someone else use the formula dp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j]), where the last one is dp[k-1, j] instead of dp[k-1, j-1]. It's not the direct sense, as if the share was bought on j-th day, then the total profit of previous transactions should be done on (j-1)th day. However, the result based on that formula is also correct, because if the share was sold on j-th day and then bought again, it is the same if we didn't trade on that day.
*/
public int MaxProfitDp(int[] prices) {
	if (prices.Length == 0) return 0;
	var dp = new int[3, prices.Length];
	for (int k = 1; k <= 2; k++) {
		for (int i = 1; i < prices.Length; i++) {
			int min = prices[0];
			for (int j = 1; j <= i; j++)
				min = Math.Min(min, prices[j] - dp[k - 1, j - 1]);
			dp[k, i] = Math.Max(dp[k, i - 1], prices[i] - min);
		}
	}

	return dp[2, prices.Length - 1];
}

/*
# 124. Binary Tree Maximum Path Sum
Given a non-empty binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.

Example 1:

Input: [1,2,3]

       1
      / \
     2   3

Output: 6
Example 2:

Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
*/

//Use a referenced result to store max result. for any tree/subtree, the max sum path passing the node is among: 1. the single node 2. the node + left branch 3. the node + right branch 4. the node + both branches.
//However in terms of the return value, it cannot contain both branches, so it is among: 1. the single node 2. the node + left 3. the node + right 4. 0
int maxPathSum(TreeNode* root) {
	int result = INT_MIN;
	traversal(result, root);
	return result;
}

int traversal(int& result, TreeNode* root) {
	if (!root) {
		return 0;
	}

	int localMax = root->val;
	int left = traversal(result, root->left);
	int right = traversal(result, root->right);

	if (left > 0) {
		localMax += left;
	}

	if (right > 0) {
		localMax += right;
	}

	result = max(result, localMax);

	//Notice the return value here !!! cannot contain both branches !!!
	return root->val + max(0, max(left, right));
}

/*
# 125. Valid Palindrome
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

Note: For the purpose of this problem, we define empty string as valid palindrome.

Example 1:

Input: "A man, a plan, a canal: Panama"
Output: true
Example 2:

Input: "race a car"
Output: false
*/

//head&tail pointers
//NOTICE HOW TO COMPARE ASCII CODE !!!!!!!!!!!!!!!!! NOTICE USE '0' NOT 0 !!!!!!!!!!!
bool isPalindrome(string s) {
	if (s.size() <= 1) {
		return true;
	}

	int left = 0;
	int right = s.size() - 1;

	while (left < right) {
		if (!(isAlpha(s[left]) || (s[left] >= '0' && s[left] <= '9'))) {
			++left;
			continue;
		}
		if (!(isAlpha(s[right]) || (s[right] >= '0' && s[right] <= '9'))) {
			--right;
			continue;
		}

		if (s[left] == s[right] || (isAlpha(s[left]) && isAlpha(s[right]) && abs(s[left] - s[right]) == 32)) {
			++left;
			--right;
		}
		else {
			return false;
		}
	}

	return true;
}

bool isAlpha(char c) {
	if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
		return true;
	}
	else {
		return false;
	}
}

/*
# 126. Word Ladder II
Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:

Only one letter can be changed at a time
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
Note:

Return an empty list if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.
Example 1:

Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output:
[
  ["hit","hot","dot","dog","cog"],
  ["hit","hot","lot","log","cog"]
]
Example 2:

Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: []

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.
*/

//Method1: DFS TLE, need to think how to improve eff
vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {

	bool hasSolution = false;
	vector<vector<string>> result;
	
	//If the endWord is not in the list, just return {};
	for (int i = 0; i < wordList.size(); ++i) {
		if (wordList[i] == endWord) {
			hasSolution = true;
			break;
		}
	}
	vector<string> cur;
	cur.push_back(beginWord);
	//sort(wordList);
	if (hasSolution) {
		Finder(beginWord, endWord, wordList, result, cur, 1);
		return result;
	}
	else {
		return {};
	}
}

void Finder(string curWord, string endWord, vector<string> wordList, vector<vector<string>>& res, vector<string>& curSol, int steps) {


	//Update result based on size.
	if (!curSol.empty() && curSol.back() == endWord) {
		if (res.empty()) {
			res.push_back(curSol);
		}
		else if (res[0].size() == curSol.size()) {
			res.push_back(curSol);
		}
		else if (res[0].size() > curSol.size()) {
			res.clear();
			res.push_back(curSol);
		}
	}
	
	//Try to improve eff that if curWord is not just one char different from endWord and steps has been reached min result - 1, just return
	if (!res.empty() && steps == res[0].size() - 1 && !oneCharDiff(curWord, endWord)) {
		return;
	}
	/*if(!res.empty() && steps >= res[0].size()){
	return;
	}*/

	for (int i = 0; i < wordList.size(); ++i) {
		//string nextWord = wordList[i];
		if (oneCharDiff(curWord, wordList[i])) {
			string nextWord = wordList[i];
			curSol.push_back(nextWord);
			wordList.erase(wordList.begin() + i);
			++steps;
			Finder(nextWord, endWord, wordList, res, curSol, steps);
			curSol.pop_back();
			--steps;
			wordList.insert(wordList.begin() + i, nextWord);
		}
	}
}

bool oneCharDiff(string s1, string s2) {

	int diff = 0;
	for (int i = 0; i < s1.size(); ++i) {
		if (s1[i] != s2[i]) {
			++diff;
			if (diff > 1) {
				return false;
			}
		}
	}
	return true;
}

//Method2: BFS. BFS paths
/*
In fact, this problem can be solved with a very standard BFS process, whose structure could haven been written by you for many many times (using while loop and a queue).
The following code is written in a very standard BFS method, which is easy to memorize.

The only tricky thing you need to remember is this is a BFS of paths not words!
So the element is the queue is a vector. That's it.

//very interesting problem
        //It can be solved with standard BFS. The tricky idea is doing BFS of paths instead of words!
        //Then the queue becomes a queue of paths.
//"visited" records all the visited nodes on this level
        //these words will never be visited again after this level 
        //and should be removed from wordList. This is guaranteed
        // by the shortest path.
*/

//The beginWord is the first level path. then Find all words in list that is one char different from beginWord and put them into the first path to generate the second level paths, then use BFS to generate further levels again and again.
vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
	//To improve eff
	bool hasSolution = false;

	for (int i = 0; i < wordList.size(); ++i) {
		if (wordList[i] == endWord) {
			hasSolution = true;
			break;
		}
	}
	if (!hasSolution) {
		return {};
	}
	unordered_set<string> dict(wordList.begin(), wordList.end());
	unordered_set<string> visited;
	vector<vector<string>> result;
	queue<vector<string>> paths;
	int level = 1;
	int minLevel = INT_MAX;
	int size = beginWord.size();
	paths.push({ beginWord });
	while (!paths.empty()) {
		vector<string> path = paths.front();
		paths.pop();

		//When a new level is started, need to remove all words that are already in paths. And clear the visited set/
		if (path.size() > level) {

			for (string s : visited) {
				dict.erase(s);
			}
			visited.clear();
			level = path.size();
		}

		//To improve the eff.
		if (level > minLevel) {
			break;
		}

		//Try to find next word
		string lastWord = path.back();
		for (int i = 0; i < size; ++i) {
			string newWord = lastWord;
			for (char c = 'a'; c <= 'z'; ++c) {
				newWord[i] = c;
				if (!dict.count(newWord)) {
					continue;
				}
				else {
					//Create a tmp for next level path, because the current path need to be reused
					vector<string> newPath = path;
					newPath.push_back(newWord);
					visited.insert(newWord);
					if (newWord == endWord) {
						minLevel = level;
						result.push_back(newPath);
					}
					else {
						//Push the new path into queue only if the newWord is not the endWord
						paths.push(newPath);
					}
				}
			}
		}
	}

	return result;
}
//Others version
vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
	vector<vector<string>> res;
	unordered_set<string> dict(wordList.begin(), wordList.end());
	vector<string> p{ beginWord };
	queue<vector<string>> paths;
	paths.push(p);
	int level = 1, minLevel = INT_MAX;
	unordered_set<string> words;
	while (!paths.empty()) {
		auto t = paths.front(); paths.pop();
		if (t.size() > level) {
			for (string w : words) dict.erase(w);
			words.clear();
			level = t.size();
			if (level > minLevel) break;
		}
		string last = t.back();
		for (int i = 0; i < last.size(); ++i) {
			string newLast = last;
			for (char ch = 'a'; ch <= 'z'; ++ch) {
				newLast[i] = ch;
				if (!dict.count(newLast)) continue;
				words.insert(newLast);
				vector<string> nextPath = t;
				nextPath.push_back(newLast);
				if (newLast == endWord) {
					res.push_back(nextPath);
					minLevel = level;
				}
				else paths.push(nextPath);
			}
		}
	}
	return res;
}

/*
# 127. Word Ladder
Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:

Only one letter can be changed at a time.
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
Note:

Return 0 if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.
Example 1:

Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output: 5

Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.
Example 2:

Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: 0

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.
*/

//Notice to check if result is empty before return.
int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
	//To improve eff
	bool hasSolution = false;

	for (int i = 0; i < wordList.size(); ++i) {
		if (wordList[i] == endWord) {
			hasSolution = true;
			break;
		}
	}
	if (!hasSolution) {
		return 0;
	}
	unordered_set<string> dict(wordList.begin(), wordList.end());
	unordered_set<string> visited;
	vector<vector<string>> result;
	queue<vector<string>> paths;
	int level = 0;
	int minLevel = wordList.size() + 1;
	int size = beginWord.size();
	paths.push({ beginWord });
	while (!paths.empty()) {
		vector<string> path = paths.front();
		paths.pop();

		//When a new level is started, need to remove all words that are already in paths. And clear the visited set/
		if (path.size() > level) {

			for (string s : visited) {
				dict.erase(s);
			}
			visited.clear();
			level = path.size();
		}

		//To improve the eff.
		if (level > minLevel) {
			break;
		}

		//Try to find next word
		string lastWord = path.back();
		for (int i = 0; i < size; ++i) {
			string newWord = lastWord;
			for (char c = 'a'; c <= 'z'; ++c) {
				newWord[i] = c;
				if (!dict.count(newWord)) {
					continue;
				}
				else {
					//Create a tmp for next level path, because the current path need to be reused
					vector<string> newPath = path;
					newPath.push_back(newWord);
					visited.insert(newWord);
					if (newWord == endWord) {
						minLevel = level + 1;
						result.push_back(newPath);
					}
					else {
						//Push the new path into queue only if the newWord is not the endWord
						paths.push(newPath);
					}
				}
			}
		}
	}
	if (result.empty()) {
		return 0;
	}
	else {
		return minLevel;
	}
	//return result;
}

/*
# 128. Longest Consecutive Sequence
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Your algorithm should run in O(n) complexity.

Example:

Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
*/

//Use set to fullfil O(n). put all nums into the set. Then traverse the original array, if cur num can be found in the set, use pre and next to represent adjacunt nums, use loop to check if they are in the set and update res. 
//Notice to erase visited nums !!!
int longestConsecutive(vector<int>& nums) {
	if (nums.empty()) {
		return 0;
	}
	int result = 0;
	unordered_set<int> digits(nums.begin(), nums.end());
	for (int i = 0; i < nums.size(); ++i) {
		if (digits.count(nums[i])) {
			//DO NOT FORGET TO ERASE visited DIGITS
			digits.erase(nums[i]);
			int pre = nums[i] - 1;
			int next = nums[i] + 1;
			while (digits.count(pre)) {
				digits.erase(pre);
				--pre;
			}
			while (digits.count(next)) {
				digits.erase(next);
				++next;
			}
			result = max(result, next - pre - 1);
		}
	}
	return result;
}

/*
# 129. Sum Root to Leaf Numbers
Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

Note: A leaf is a node with no children.

Example:

Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
Example 2:

Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
*/

//Notice how to calc curSum.
int sumNumbers(TreeNode* root) {
	if (!root) {
		return 0;
	}
	else {
		//int result = root->val;
		int result = 0;
		traversal(root, result, 0);
		return result;
	}

}

void traversal(TreeNode* root, int& result, int curSum) {
	if (!root) {
		return;
	}
	else if (!root->left && !root->right) {
		curSum = curSum * 10 + root->val;
		result += curSum;
		return;
	}

	curSum = curSum * 10 + root->val;
	if (root->left) {

		traversal(root->left, result, curSum);
	}

	if (root->right) {
		traversal(root->right, result, curSum);
	}
}

/*
# 130. Surrounded Regions
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.

Example:

X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X
Explanation:

Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
*/

//Use a bool table to store if the 'O' should be changed. Initial all 'O' pos as true. Then traverse four borders, all 'O' on the border and all 'O' adjacent to it should be changed to false. 
//Can be improved that only use the input table to mark. Still traverse four borders and mark all adjacent 'O' to '$' etc. 
void solve(vector<vector<char>>& board) {
	if (board.empty() || board[0].empty()) {
		return;
	}
	int height = board.size();
	int width = board[0].size();
	vector<vector<bool>> change(height, vector<bool>(width, true));
	for (int i = 0; i < height; ++i) {
		for (int j = 0; j < width; ++j) {
			if (board[i][j] == 'X') {
				change[i][j] = false;
			}
			else {
				change[i][j] = true;
			}
		}
	}

	for (int i = 0; i < width; ++i) {
		if (change[0][i] == true) {
			//change[0][i] == false;
			checkRemain(0, i, board, change);
		}
	}
	for (int i = 1; i < height; ++i) {
		if (change[i][width - 1] == true) {
			//change[0][i] == false;
			checkRemain(i, width - 1, board, change);
		}
	}
	for (int i = width - 2; i >= 0; --i) {
		if (change[height - 1][i] == true) {
			//change[0][i] == false;
			checkRemain(height - 1, i, board, change);
		}
	}
	for (int i = height - 2; i > 0; --i) {
		if (change[i][0] == true) {
			//change[0][i] == false;
			checkRemain(i, 0, board, change);
		}
	}

	for (int i = 0; i < height; ++i) {
		for (int j = 0; j < width; ++j) {
			if (board[i][j] == 'O' && change[i][j] == true) {
				board[i][j] = 'X';
			}
		}
	}

}

void checkRemain(int row, int col, vector<vector<char>>& board, vector<vector<bool>>& change) {
	if (row < 0 || row >= board.size() || col < 0 || col >= board[0].size() || change[row][col] == false) {
		return;
	}

	if (change[row][col] == true) {
		change[row][col] = false;
		checkRemain(row - 1, col, board, change);
		checkRemain(row + 1, col, board, change);
		checkRemain(row, col - 1, board, change);
		checkRemain(row, col + 1, board, change);
	}
}

/*
# 131. Palindrome Partitioning
Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:

Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]
*/

//Use P and C method. Notice how to set start and end.
vector<vector<string>> partition(string s) {
	if (s.empty()) {
		return {};
	}
	else if (s.size() == 1) {
		return { { s } };
	}
	vector<vector<string>> result;
	vector<string> cur;

	partitionDFS(s, cur, result, 0);
	return result;

}

void partitionDFS(string s, vector<string>& cur, vector<vector<string>>& result, int start) {
	if (start == s.size()) {
		result.push_back(cur);
		return;
	}

	for (int i = start; i < s.size(); ++i) {
		if (isPalindrome(s, start, i)) {
			cur.push_back(s.substr(start, i - start + 1));
			partitionDFS(s, cur, result, i + 1);
			cur.pop_back();
		}
	}
}

bool isPalindrome(string s, int start, int end) {
	if (start > end) {
		return false;
	}
	else if (start == end) {
		return true;
	}

	while (start < end) {
		if (s[start] == s[end]) {
			++start;
			--end;
		}
		else {
			return false;
		}
	}
	return true;
}

/*
# 132. Palindrome Partitioning II
Given a string s, partition s such that every substring of the partition is a palindrome.

Return the minimum cuts needed for a palindrome partitioning of s.

Example:

Input: "aab"
Output: 1
Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.
*/

//Use dp. Notice minCuts[0] = -1 so that when 1st to ith chars are pali, minCuts[i] = 1 + (-1) = 0 cut. minCuts[i] represents how many cuts that the first i chars need. Initial value of minCuts[i] is the i - 1;
//then use i to traverse from 1 to len. For each i, use another int j from 0 to i to check if there is a pali from j to i, if so, the minCuts[i] should be updated to 1 + minCuts[j - 1]. Notice j can equals i because a single char is also a pali (in this case minCuts[i] remains the initial value).
int minCut(string s) {

	int len = s.size();
	vector<int> minCuts(len + 1, -1);

	for (int i = 1; i < len + 1; ++i) {
		minCuts[i] = i - 1;
	}

	for (int i = 1; i < len + 1; ++i) {
		for (int j = 1; j <= i; ++j) {
			if (isPalindrome(s, j - 1, i - 1)) {
				minCuts[i] = min(minCuts[i], minCuts[j - 1] + 1);
			}
		}
	}
	return minCuts[len];
}

bool isPalindrome(string s, int start, int end) {
	if (start > end) {
		return false;
	}
	else if (start == end) {
		return true;
	}

	while (start < end) {
		if (s[start] == s[end]) {
			++start;
			--end;
		}
		else {
			return false;
		}
	}
	return true;
}

/*
# 133. Clone Graph
Given the head of a graph, return a deep copy (clone) of the graph. Each node in the graph contains a label (int) and a list (List[UndirectedGraphNode]) of its neighbors. There is an edge between the given node and each of the nodes in its neighbors.


OJ's undirected graph serialization (so you can understand error output):
Nodes are labeled uniquely.

We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
 

As an example, consider the serialized graph {0,1,2#1,2#2,2}.

The graph has a total of three nodes, and therefore contains three parts as separated by #.

First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
Second node is labeled as 1. Connect node 1 to node 2.
Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.
 

Visually, the graph looks like the following:

       1
      / \
     /   \
    0 --- 2
         / \
         \_/
Note: The information about the tree serialization is only meant so that you can understand error output if you get a wrong answer. You don't need to understand the serialization to solve the problem.
*/
/**
 * Definition for undirected graph.
 * struct UndirectedGraphNode {
 *     int label;
 *     vector<UndirectedGraphNode *> neighbors;
 *     UndirectedGraphNode(int x) : label(x) {};
 * };
 */
 
//Use a map to store existing nodes. Use DFS to visit all nodes through neighbors vector.
UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
	if (!node) {
		return NULL;
	}
	unordered_map<int, UndirectedGraphNode*> nodes;
	return cloneGraphNode(nodes, node);
}

UndirectedGraphNode* cloneGraphNode(unordered_map<int, UndirectedGraphNode*>& nodes, UndirectedGraphNode* origin) {
	if (nodes.count(origin->label)) {
		return nodes[origin->label];
	}

	UndirectedGraphNode* newNode = new UndirectedGraphNode(origin->label);
	vector<UndirectedGraphNode * > neigh(origin->neighbors.begin(), origin->neighbors.end());
	nodes[newNode->label] = newNode;
	for (int i = 0; i < neigh.size(); ++i) {
		newNode->neighbors.push_back(cloneGraphNode(nodes, neigh[i]));
	}
	return newNode;
}

/*
# 134. Gas Station
There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.

Note:

If there exists a solution, it is guaranteed to be unique.
Both input arrays are non-empty and have the same length.
Each element in the input arrays is a non-negative integer.
Example 1:

Input: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

Output: 3

Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
Example 2:

Input: 
gas  = [2,3,4]
cost = [3,4,3]

Output: -1

Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.
*/

//Notice firstly total should be greater than 0, or return -1. Traverse from [0], if current sum to [i] is less than zero, then from [0] to [i] cann't be start point, so set start point as [i + 1] and sum = 0.
//Untial traverse to the tail, if total > 0 then the "start" stored is the result. Because total > 0 and from [start] to tail is greater than 0, then we know the gas is enough from [0] to [start] again.   
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {

	int total = 0;
	int sum = 0;
	int start = 0;
	for (int i = 0; i < gas.size(); ++i) {
		total += gas[i] - cost[i];
		sum += gas[i] - cost[i];
		if (sum < 0) {
			start = i + 1;
			sum = 0;
		}
	}

	if (total >= 0) {
		return start;
	}
	else {
		return -1;
	}
}

/*
# 135. Candy
There are N children standing in a line. Each child is assigned a rating value.

You are giving candies to these children subjected to the following requirements:

Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.
What is the minimum candies you must give?

Example 1:

Input: [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.
Example 2:

Input: [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.
             The third child gets 1 candy because it satisfies the above two conditions.
*/
//Method1: traverse from left to right and compare [i] with [i - 1]. if [i] needs more candy, just add one. If [i - 1] needs more candy, need to traverse back to [0] to update candies.
int candy(vector<int>& ratings) {
	if (ratings.empty()) {
		return 0;
	}
	else if (ratings.size() == 1) {
		return 1;
	}
	int result = 0;
	vector<int> candies(ratings.size(), 1);
	for (int i = 1; i < candies.size(); ++i) {
		if (ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1]) {
			candies[i] = candies[i - 1] + 1;
		}
		else if (ratings[i] < ratings[i - 1] && candies[i] >= candies[i - 1]) {
			candies[i - 1] = candies[i] + 1;
			int index = i - 1;
			while (index - 1 >= 0 && ratings[index] < ratings[index - 1] && candies[index] >= candies[index - 1]) {
				candies[index - 1] = candies[index] + 1;
				--index;
			}
		}
	}

	for (int i = 0; i < candies.size(); ++i) {
		result += candies[i];
	}
	return result;
}

//Method2: traverse from [0] to [n - 1]. After that traverse from [n - 1] to [0]
//Notice when traverse back, it is not just nums[i] + 1 because nums[i - 1] may greater than nums[i] + 1
int candy(vector<int>& ratings) {
	int res = 0, n = ratings.size();
	vector<int> nums(n, 1);
	for (int i = 0; i < n - 1; ++i) {
		if (ratings[i + 1] > ratings[i]) nums[i + 1] = nums[i] + 1;
	}
	for (int i = n - 1; i > 0; --i) {
		if (ratings[i - 1] > ratings[i]) nums[i - 1] = max(nums[i - 1], nums[i] + 1);
	}
	for (int num : nums) res += num;
	return res;
}

/*
# 136. Single Number
Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:

Input: [2,2,1]
Output: 1
Example 2:

Input: [4,1,2,1,2]
Output: 4
*/

//Method1 : traverse from beginning, search for dup nums and erase both.
int singleNumber(vector<int>& nums) {

	if (nums.size() == 1) {
		return nums[0];
	}
	for (int i = 0; i < nums.size();) {
		for (int j = i + 1; i < nums.size(); ++j) {
			if (nums[j] == nums[i]) {
			//Notice must erase j firstly !! because index would change.
				nums.erase(nums.begin() + j);
				nums.erase(nums.begin() + i);
				break;
			}
			else if (j == nums.size() - 1) {
				return nums[i];
			}
		}
		if (i == nums.size() - 1) {
			return nums[i];
		}
	}
	return 0;
}

//Method2: use ^
//Notice ^ has Associativity property
int singleNumber(vector<int>& nums) {
	int res = 0;
	for (auto num : nums) res ^= num;
	return res;
}

/*
# 137. Single Number II
Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:

Input: [2,2,3,2]
Output: 3
Example 2:

Input: [0,1,0,1,0,1,99]
Output: 99
*/

//oneTimeBit represents 1 on a bit appears one time. Similar for twoTimeBit and threeTimeBit.
//Need to update twoTimeBit firstly because if 1 on a bit appears two times, the bit in oneTimeBit will be updated to 0.
//oneTimeBit may contain 1 on a bit that appears 3 times, so need to & ~threeTimeBit to make sure 1 in oneTimeBit only represents appearence of one time.
//twoTimeBit has to be updated after updating threeTimeBit because the update by or operation may keep the appearence of three times.
int singleNumber(vector<int>& nums) {

	int oneTimeBit = 0;
	int twoTimeBit = 0;
	int threeTimeBit = 0;

	for (int i = 0; i < nums.size(); ++i) {

		twoTimeBit = twoTimeBit | (nums[i] & oneTimeBit);
		oneTimeBit = oneTimeBit ^ nums[i];
		threeTimeBit = oneTimeBit & twoTimeBit;

		oneTimeBit = ~threeTimeBit & oneTimeBit;
		twoTimeBit = ~threeTimeBit & twoTimeBit;
	}

	return oneTimeBit;
}

/*
# 138. Copy List with Random Pointer
A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.

Return a deep copy of the list.
*/

//method1: Use a map<originalNode*, newNode*> to recognise a node and check if it is already created.
RandomListNode *copyRandomList(RandomListNode *head) {
	if (!head) {
		return head;
	}

	unordered_map<RandomListNode*, RandomListNode*> createdNodes;
	return copyNode(createdNodes, head);
}

RandomListNode* copyNode(unordered_map<RandomListNode*, RandomListNode*>& nodes, RandomListNode* originNode) {
	if (nodes.count(originNode)) {
		return nodes[originNode];
	}

	RandomListNode* newNode = new RandomListNode(originNode->label);
	nodes[originNode] = newNode;
	if (originNode->next) {
		newNode->next = copyNode(nodes, originNode->next);
	}
	if (originNode->random) {
		newNode->random = copyNode(nodes, originNode->random);
	}
	return newNode;
}

//method2: copy a newNode in the next location of each old node in original list. So we have that cur->next->random = cur->random->next

/*
# 139. Word Break
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
Example 2:

Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false
*/

//Use dp. dp[i] means the first i chars(notice index in s is i - 1) can be breaked. dp[0] is always true because it is used to check the substr from s[0] to ith char.
//dp[i] is true if substr(0, i) is in dict or, dp[j] is true and substr(j, i - j) is in dict. Notice the index ! 
bool wordBreak(string s, vector<string>& wordDict) {
	unordered_set<string> words(wordDict.begin(), wordDict.end());
	vector<bool> breakable(s.size() + 1, false);
	breakable[0] = true;

	for (int i = 1; i < s.size() + 1; ++i) {
		for (int j = 0; j < i; ++j) {
			if (breakable[j] == true && words.count(s.substr(j, i - j))) {
				breakable[i] = true;
				break;
			}
		}
	}
	return breakable[s.size()];
}

/*
# 140. Word Break II
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
Output:
[
  "cats and dog",
  "cat sand dog"
]
Example 2:

Input:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
Output:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
Explanation: Note that you are allowed to reuse a dictionary word.
Example 3:

Input:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
Output:
[]
*/

//Use DFS P and C, but need to use a map and some modificaitons to improve eff.
//The map stores breakable cases for any breakable str in dfs.
vector<string> wordBreak(string s, vector<string>& wordDict) {
	unordered_set<string> dict(wordDict.begin(), wordDict.end());
	unordered_map<string, vector<vector<string>>> breakable;
	vector<string> result;
	vector<vector<string>> rawResult;
	rawResult = DFSresolver(s, dict, breakable);
	
	//Handle output format
	for (int i = 0; i < rawResult.size(); ++i) {
		string curRes;
		for (int j = 0; j < rawResult[i].size(); ++j) {
			curRes.append(rawResult[i][j]);
			if (j != rawResult[i].size() - 1) {
				curRes.push_back(' ');
			}
		}
		result.push_back(curRes);
	}
	return result;
}

vector<vector<string>> DFSresolver(string input, unordered_set<string> dict, unordered_map<string, vector<vector<string>>>& breakable) {
	
	//Improve eff
	if (breakable.count(input)) {
		return breakable[input];
	}
	
	
	if (input.empty()) {
	//Must return {{}} not just {}, because after return to last rec, {{}} would be updated to {{lastWord}} as result; 
		return { {} };
	}

	vector<vector<string>> res;
	
	//Traverse the dict, not s, to improve eff.
	for (string word : dict) {
		if (input.substr(0, word.size()) == word) {
			vector<vector<string>> followBreak = DFSresolver(input.substr(word.size()), dict, breakable);
			for (int i = 0; i < followBreak.size(); ++i) {
				followBreak[i].insert(followBreak[i].begin(), word);
				res.push_back(followBreak[i]);
			}
		}
	}
	breakable[input] = res;
	return res;
}

/*
# 141. Linked List Cycle
Given a linked list, determine if it has a cycle in it.

To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

 

Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the second node.
*/

//Fast and slow pointers. If they meet, then there is a cycle.
bool hasCycle(ListNode *head) {
	if (!head) {
		return false;
	}

	ListNode* slow = head;
	ListNode* fast = head;

	while (fast->next && fast->next->next) {
		slow = slow->next;
		fast = fast->next->next;
		if (slow == fast) {
			return true;
		}
	}
	return false;
}

/*
# 142. Linked List Cycle II
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

Note: Do not modify the linked list.

 

Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.
*/

//Use slow&fast pointers. When they meets at index i, assign fast = head, then both slow and fast move one node each time. When they meet again at a index j, j is the entry.
//because when they meet the first time at i, fast passed twice nodes long as slow passed and the difference is the length of the cycle, which also equals the length from head to i. if the cycle entry is j, then the distance from i to j equals from head to j.
ListNode *detectCycle(ListNode *head) {
	if (!head) {
		return NULL;
	}

	ListNode* slow = head;
	ListNode* fast = head;

	while (fast && fast->next) {
		slow = slow->next;
		fast = fast->next->next;
		if (slow == fast) {
			fast = head;
			break;
		}
	}

	if (!fast || !fast->next) {
		return NULL;
	}

	while (slow != fast) {
		slow = slow->next;
		fast = fast->next;
	}

	return slow;
}

/*
# 143. Reorder List
Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You may not modify the values in the list's nodes, only nodes itself may be changed.

Example 1:

Given 1->2->3->4, reorder it to 1->4->2->3.
Example 2:

Given 1->2->3->4->5, reorder it to 1->5->2->4->3.
*/

//Use slow&fast pointers to find mid of the list. cut the list into first half and second half. Then reverse the second half and insert each node in the reversed second half into the first half.
void reorderList(ListNode* head) {
	if (!head || !head->next) {
		return;
	}

	ListNode* slow = head;
	ListNode* fast = head;

	while (fast && fast->next) {
		slow = slow->next;
		fast = fast->next->next;
	}

	ListNode* half = slow->next;

	slow->next = NULL;
	slow = head;
	half = ReverseList(half);

	while (half) {
		ListNode* cur = half;
		half = cur->next;
		cur->next = slow->next;
		slow->next = cur;
		slow = cur->next;
	}

	//return head;
}

ListNode* ReverseList(ListNode* head) {
	if (!head) {
		return NULL;
	}
	ListNode dummyHead(0);
	//ListNode* dummy = &dummyHead;
	dummyHead.next = head;
	//head = &dummyHead;

	//ListNode* newTail = dummyHead->next;
	while (head->next) {
		ListNode* tmp = head->next;
		head->next = tmp->next;
		tmp->next = dummyHead.next;
		dummyHead.next = tmp;
	}
	return dummyHead.next;
}

/*
# 146. LRU Cache
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
*/

//Method1: use a map to store keys&values. Use a vector to control recent access. But get needs O(n) time.
class LRUCache {
public:
	LRUCache(int capacity) {
		maxCapacity = capacity;
		//cache = new vector<int>(maxCapacity,);
		//recently = new vector<int>(maxCapacity, -1);
	}

	int get(int key) {
		if (cache.count(key)) {

			for (int i = 0; i < recently.size(); ++i) {
				if (key == recently[i]) {
					recently.erase(recently.begin() + i);
					recently.insert(recently.begin(), key);
					break;
				}
			}
			return cache[key];
		}
		else {
			return -1;
		}
	}

	void put(int key, int value) {
		if (cache.count(key)) {
			cache[key] = value;
			for (int i = 0; i < recently.size(); ++i) {
				if (key == recently[i]) {
					recently.erase(recently.begin() + i);
					recently.insert(recently.begin(), key);
					break;
				}
			}
		}
		else {
			if (recently.size() < maxCapacity) {
				cache[key] = value;
				recently.insert(recently.begin(), key);
			}
			else {
				cache.erase(recently.back());
				recently.pop_back();
				cache[key] = value;
				recently.insert(recently.begin(), key);
			}
		}
	}
private:
	int maxCapacity;
	//vector<int> cache;
	//unordered_map<int,int> cache;
	map<int, int> cache;
	//key is key, value is index in recently;
	//unordered_map<int,int> recTime;
	//queue<int> recently;
	vector<int> recently;
};

//Method2: use a list to control recent access. use a map to store key as key and the iterator of the pair in list as value;
//notice how to use lsit.splice() to change location of the pair in list to control recent access.
class LRUCache {
public:
	LRUCache(int capacity) {
		maxCapacity = capacity;
		//cache = new vector<int>(maxCapacity,);
		//recently = new vector<int>(maxCapacity, -1);
	}

	int get(int key) {
		if (cache.count(key)) {
			//Move the recent access one to front
			recent.splice(recent.begin(), recent, cache[key]);
			return cache[key]->second;
		}
		else {
			return -1;
		}
	}

	void put(int key, int value) {
		if (cache.count(key)) {
			cache[key]->second = value;
			recent.splice(recent.begin(), recent, cache[key]);
		}
		else {
			if (cache.size() < maxCapacity) {
				recent.insert(recent.begin(), pair<int, int>(key, value));
				cache[key] = recent.begin();
			}
			else {
				int k = recent.rbegin()->first;
				recent.pop_back();
				cache.erase(k);
				recent.insert(recent.begin(), pair<int, int>(key, value));
				cache[key] = recent.begin();
			}
		}
	}
private:
	int maxCapacity;
	map<int, list<pair<int, int>>::iterator> cache;
	list<pair<int, int>> recent;
};

/*
# 147. Insertion Sort List
Sort a linked list using insertion sort.
A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.
With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list
 

Algorithm of Insertion Sort:

Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.
At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.
It repeats until no input elements remain.

Example 1:

Input: 4->2->1->3
Output: 1->2->3->4
Example 2:

Input: -1->5->3->4->0
Output: -1->0->3->4->5
*/
//Notice how to handle the new list and how to find the index.
ListNode* insertionSortList(ListNode* head) {
	if (!head || !head->next) {
		return head;
	}

	ListNode dummyHead(0);
	ListNode* dummy = &dummyHead;

	while (head) {
		ListNode* tmp = head;
		head = head->next;

		while (dummy->next && tmp->val > dummy->next->val) {
			dummy = dummy->next;
		}

		tmp->next = dummy->next;
		dummy->next = tmp;

		//dummy->next = tmp;
		dummy = &dummyHead;
	}
	return dummyHead.next;
}

/*
# 148. Sort List
Sort a linked list in O(n log n) time using constant space complexity.

Example 1:

Input: 4->2->1->3
Output: 1->2->3->4
Example 2:

Input: -1->5->3->4->0
Output: -1->0->3->4->5
*/

//Use slow&fast to find mid. Notice must have a pre to point to the pre node of slow(slow may locates at one more node than mid).
ListNode* sortList(ListNode* head) {
	if (!head || !head->next) {
		return head;
	}

	ListNode* slow = head;
	ListNode* fast = head;
	ListNode* pre = head;
	while (fast && fast->next) {
		pre = slow;
		slow = slow->next;
		fast = fast->next->next;
	}

	//fast = slow->next;
	pre->next = NULL;

	return mergeTwoList(sortList(head), sortList(slow));
}

ListNode* mergeTwoList(ListNode* list1, ListNode* list2) {
	ListNode dummyHead(0);
	ListNode* head = &dummyHead;

	while (list1 && list2) {
		if (list1->val < list2->val) {
			head->next = list1;
			list1 = list1->next;
		}
		else {
			head->next = list2;
			list2 = list2->next;
		}
		head = head->next;
	}

	if (list1) {
		head->next = list1;
	}
	else if (list2) {
		head->next = list2;
	}
	return dummyHead.next;
}

/*
# 149. Max Points on a Line
Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.

Example 1:

Input: [[1,1],[2,2],[3,3]]
Output: 3
Explanation:
^
|
|        o
|     o
|  o  
+------------->
0  1  2  3  4
Example 2:

Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
Output: 4
Explanation:
^
|
|  o
|     o        o
|        o
|  o        o
+------------------->
0  1  2  3  4  5  6
*/

//Check by slope. Traverse for each point(p1): traverse all other points points(p2), p1,p2 forms a line with a certain slope. ++map[slope] for each p2(example: p1:(1,1), p2:(2,2), p3:(3,3), p4,p5... p1 and p2 forms a line whose slope is 1, while p1 and p3 also has a slope 1, notice p1 is certain).
//The slope is represented by a pair<int,int> that is the two nums as reduction of a fraction(example: 4/8, 3/6, 1/2 all belong to <1,2>) to prevent double nums.
//Notice there might be some dup points, use a dup to count them.
//Notice must use map, not unordered_map.
//Remember how to calc GCD.

/**
 * Definition for a point.
 * struct Point {
 *     int x;
 *     int y;
 *     Point() : x(0), y(0) {}
 *     Point(int a, int b) : x(a), y(b) {}
 * };
 */
 
int maxPoints(vector<Point>& points) {

	if (points.size() <= 1) {
		return points.size();
	}

	int res = 0;

	for (int i = 0; i < points.size(); ++i) {
		map<pair<int, int>, int> slopes;
		int dup = 1;
		for (int j = i + 1; j < points.size(); ++j) {
			if (points[i].x == points[j].x && points[i].y == points[j].y) {
				++dup;
				continue;
			}
			else {
				int dx = points[i].x - points[j].x;
				int dy = points[i].y - points[j].y;
				int gcd = GCDofTwo(dx, dy);
				++slopes[{dx / gcd, dy / gcd}];
			}
		}
		for (auto it = slopes.begin(); it != slopes.end(); ++it) {
			res = max(res, it->second + dup);
		}
		//cover the case that all points are the same(map is empty)
		res = max(dup, res);
	}
	return res;
}

int GCDofTwo(int n1, int n2) {
	if (n2 == 0) {
		return n1;
	}
	else {
		return GCDofTwo(n2, n1%n2);
	}
}

/*
# 150. Evaluate Reverse Polish Notation
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Note:

Division between two integers should truncate toward zero.
The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.
Example 1:

Input: ["2", "1", "+", "3", "*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
Example 2:

Input: ["4", "13", "5", "/", "+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
Example 3:

Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
Output: 22
Explanation: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
*/

//Method1: use recursion. Notice it is reversed, so start from back. Notice to pop_back().
//Method2: use stack. If meet nums, push nums into stack, if meet ops, calc op with two top elements.
int evalRPN(vector<string>& tokens) {
	string cur = tokens.back();

	if (cur != "+" && cur != "-" && cur != "*" && cur != "/") {
		tokens.pop_back();
		return stoi(cur);
	}
	else {
		tokens.pop_back();
		int v1 = evalRPN(tokens);
		int v2 = evalRPN(tokens);

		if (cur == "+") {
			return v2 + v1;
		}
		else if (cur == "-") {
			return v2 - v1;
		}
		else if (cur == "*") {
			return v2 * v1;
		}
		else if (cur == "/") {
			return v2 / v1;
		}
	}
}

/*
# 151. Reverse Words in a String
Given an input string, reverse the string word by word.

Example:  

Input: "the sky is blue",
Output: "blue is sky the".
Note:

A word is defined as a sequence of non-space characters.
Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.
You need to reduce multiple spaces between two words to a single space in the reversed string.
Follow up: For C programmers, try to solve it in-place in O(1) space.
*/

//Reverse the whole s firstly(Notice spaces in head and tail would also be reversed), then reverse each word. 
void reverseWords(string &s) {
	if (s.empty()) {
		return;
	}

	reverse(s.begin(), s.end());
	int i = 0;
	while (i < s.size()) {
		while (i < s.size() && s[i] == ' ') {
			s.erase(s.begin() + i);
		}
		int start = i;
		while (i < s.size() && s[i] != ' ') {
			++i;
		}
		int end = i;
		reverse(s.begin() + start, s.begin() + end);
		//To keep one space
		++i;
	}
	//There might be one space in tail. 
	//Such as " 1" reverse whole s-> "1 " reverse each word->"1 " resize to size-1->"1"
	if (!s.empty() && s[s.size() - 1] == ' ') s.resize(s.size() - 1);
	return;
}

/*
# 152.Maximum Product Subarray
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:

Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
*/
//use dp. minPro[i] and maxPro[i] means the min/max subarray product include nums[i], and they are one of min[i - 1] * nums[i], max[i - 1] * nums[i], nums[i]
//Notice the result might not maxPro[size - 1], need to update the result for each loop. The key is 0 and even/uneven negative numbers. 
int maxProduct(vector<int>& nums) {
	if (nums.empty()) {
		return 0;
	}
	else if (nums.size() == 1) {
		return nums[0];
	}

	int result = 0;
	vector<int> maxPro(nums.size(), 0);
	vector<int> minPro(nums.size(), 0);

	maxPro[0] = nums[0];
	minPro[0] = nums[0];

	for (int i = 0; i < nums.size(); ++i) {
		int m1 = max(maxPro[i - 1] * nums[i], minPro[i - 1] * nums[i]);
		maxPro[i] = max(m1, nums[i]);
		int m2 = min(maxPro[i - 1] * nums[i], minPro[i - 1] * nums[i]);
		minPro[i] = min(m2, nums[i]);
		result = max(result, maxPro[i]);
	}

	return result;
}

/*
# 153. Find Minimum in Rotated Sorted Array
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).

Find the minimum element.

You may assume no duplicate exists in the array.

Example 1:

Input: [3,4,5,1,2] 
Output: 1
Example 2:

Input: [4,5,6,7,0,1,2]
Output: 0
*/

//Use binary search, by comparing nums[mid] and nums[right] to know where the "peak" is 
int findMin(vector<int>& nums) {
	if (nums.empty()) {
		return 0;
	}
	else if (nums.size() == 1) {
		return nums[0];
	}

	int left = 0;
	int right = nums.size() - 1;

	while (left + 1 < right) {
		int mid = (right - left) / 2 + left;
		if (nums[mid] > nums[right]) {
			left = mid + 1;
		}
		else {
			//cannot be mid - 1 because mid might be the smallest
			right = mid;
		}
	}

	if (nums[left] < nums[right]) {
		return nums[left];
	}
	else {
		return nums[right];
	}

}

/*
# 154. Find Minimum in Rotated Sorted Array II
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).

Find the minimum element.

The array may contain duplicates.

Example 1:

Input: [1,3,5]
Output: 1
Example 2:

Input: [2,2,2,0,1]
Output: 0
Note:

This is a follow up problem to Find Minimum in Rotated Sorted Array.
Would allow duplicates affect the run-time complexity? How and why?
*/

//Notice this time there might be dups. Need to --right when nums[mid] == nums[right] UNTIL mid = right because mid might be the smallest. 
int findMin(vector<int>& nums) {
	if (nums.empty()) {
		return 0;
	}
	else if (nums.size() == 1) {
		return nums[0];
	}

	int left = 0;
	int right = nums.size() - 1;

	while (left + 1 < right) {
		int mid = (right - left) / 2 + left;
		if (nums[mid] > nums[right]) {
			left = mid + 1;
		}
		else if (nums[mid] < nums[right]) {
			//cannot be mid - 1 because mid might be the smallest
			right = mid;
		}
		else {
			while (mid < right && nums[mid] == nums[right]) {
				--right;
			}
		}
	}

	if (nums[left] < nums[right]) {
		return nums[left];
	}
	else {
		return nums[right];
	}
}

/*
# 155. Min Stack
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.
Example:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.
*/

//Method1: use a int to store min value. Notice how to save the min value when a smaller one comes, it is needed when pop
class MinStack {
public:
	/** initialize your data structure here. */
	MinStack() {
		minVal = INT_MAX;
	}

	void push(int x) {
		//Push a dup "last minVal" when a new minVal comes, to save the new minVal when pop();
		if (x <= minVal) {
			nums.push(minVal);
			minVal = x;
		}
		nums.push(x);
	}

	void pop() {

		if (nums.top() == minVal) {
			nums.pop();

			//Get and pop the "dup" the new minVal here
			minVal = nums.top();
			nums.pop();
		}
		else {
			nums.pop();
		}
	}

	int top() {
		return nums.top();
	}

	int getMin() {
		return minVal;
	}
private:
	stack<int> nums;
	int minVal;
};

//method2: use another stack to store minVals.

/**
* Your MinStack object will be instantiated and called as such:
* MinStack obj = new MinStack();
* obj.push(x);
* obj.pop();
* int param_3 = obj.top();
* int param_4 = obj.getMin();
*/

/*
$ 156. Binary Tree Upside Down
Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.

For example:

Given a binary tree {1,2,3,4,5},

    1

   / \

  2   3

 / \

4   5

return the root of the binary tree [4,5,2,#,#,3,1].

   4

  / \

 5   2

    / \

   3   1  
*/

//The most left node should be the new root. For each node and its left, right branch node, the left node is the new root, the ori root is new right node, the ori right is the new left node.
//method1: recursion. Notice must recursion firstly, then upside down itself.
// Recursion
class Solution {
public:
    TreeNode *upsideDownBinaryTree(TreeNode *root) {
        if (!root || !root->left) return root;
        TreeNode *l = root->left, *r = root->right;
        TreeNode *res = upsideDownBinaryTree(l);
        l->left = r;
        l->right = root;
        root->left = NULL;
        root->right = NULL;
        return res;
    }
};

//method2: iterative
// Iterative
class Solution {
public:
    TreeNode *upsideDownBinaryTree(TreeNode *root) {
        TreeNode *cur = root, *pre = NULL, *next = NULL, *tmp = NULL;
        while (cur) {
            next = cur->left;
            cur->left = tmp;
            tmp = cur->right;
            cur->right = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};

/*
$ 159.Longest Substring with At Most Two Distinct Characters
*/
//Sliding window. Use a map to store how many distinct chars and appear times. When there are more than 2 distinct chars, shrink left until less than 2 distinct chars.
//Notice how to update res.
class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {
        int res = 0, left = 0;
        unordered_map<char, int> m;
        for (int i = 0; i < s.size(); ++i) {
            ++m[s[i]];
            while (m.size() > 2) {
                if (--m[s[left]] == 0) m.erase(s[left]);
                ++left;
            }
            res = max(res, i - left + 1);
        }
        return res;
    }
};

/*
# 160. Intersection of Two Linked Lists
Write a program to find the node at which the intersection of two singly linked lists begins.

For example, the following two linked lists:
begin to intersect at node c1.

 

Example 1:
Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
Output: Reference of the node with value = 8
Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
*/

//Method1: like a cycle
//Move a and b, if a/b reaches end, then point a/b to headB/A. if they can meet again, then the meet node is the result.
//Notice the edge cases!!!
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
	if (!headA || !headB) {
		return NULL;
	}
	else if (headA == headB) {
		return headA;
	}

	ListNode* curA = headA;
	ListNode* curB = headB;
	bool aEnd = false;
	bool bEnd = false;
	while (!aEnd || !bEnd) {
		curA = curA->next;
		curB = curB->next;
		if (!curA) {
			curA = headB;
			aEnd = true;
		}
		if (!curB) {
			curB = headA;
			bEnd = true;
		}
	}

	while (curA && curB) {

		//Must check this firstly !!
		if (curA == curB) {
			return curA;
		}
		curA = curA->next;
		curB = curB->next;

	}
	return NULL;
}

//method2: calc length of A and B, then get the difference d. cut the longer one by d nodes. 

/*
$ 161. One Edit Distance
Given two strings S and T, determine if they are both one edit distance apart.
*/
//Totally 3 cases
class Solution {
public:
    bool isOneEditDistance(string s, string t) {
        if (s.size() < t.size()) swap(s, t);
        int m = s.size(), n = t.size(), diff = m - n;
        //case 1: size difference is greater than 2, return false
        if (diff >= 2) return false;
        //case 2: size difference is 1, only one char more, and left part should be same.
        else if (diff == 1) {
            for (int i = 0; i < n; ++i) {
                if (s[i] != t[i]) {
                    return s.substr(i + 1) == t.substr(i);
                }
            }
            return true;
        
        } else {
        //case 3: the same length, check if only one char is different
            int cnt = 0;
            for (int i = 0; i < m; ++i) {
                if (s[i] != t[i]) ++cnt;
            }
            return cnt == 1;
        }
    }
};

/*
# 162. Find Peak Element
A peak element is an element that is greater than its neighbors.

Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that nums[-1] = nums[n] = -∞.

Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Example 2:

Input: nums = [1,2,1,3,5,6,4]
Output: 1 or 5 
Explanation: Your function can return either index number 1 where the peak element is 2, 
             or index number 5 where the peak element is 6.
Note:

Your solution should be in logarithmic complexity.
*/
//method2: binary search. it is possible because in description there are nums[i] ≠ nums[i+1] and nums[-1] = nums[n] = -∞.
int findPeakElement(vector<int>& nums) {
	if (nums.size() == 1) {
		return 0;
	}

	int left = 0;
	int right = nums.size() - 1;

	while (left + 1 < right) {
		int mid = (right - left) / 2 + left;
		if (nums[mid] > nums[mid + 1]) {
			if (nums[mid] > nums[mid - 1]) {
				return mid;
			}
			else {
				right = mid;
			}
		}
		else {
			left = mid + 1;
		}
	}

	if (nums[left] > nums[right]) {
		return left;
	}
	else {
		return right;
	}
}

//method1: traverse
int findPeakElement(vector<int>& nums) {
	if (nums.size() == 1) {
		return 0;
	}
	int size = nums.size();

	if (nums[0] > nums[1]) {
		return 0;
	}
	else if (nums[size - 1] > nums[size - 2]) {
		return size - 1;
	}

	int start = 0;
	int end = size - 1;

	for (int i = 1; i < size - 1; ++i) {
		if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {
			return i;
		}
		else if (nums[i] >= nums[i + 1]) {
			while (i + 1 < size - 1 && nums[i] >= nums[i + 1]) {
				++i;
			}
		}
	}
	return -1;
}

/*
# 164. Maximum Gap
Given an unsorted array, find the maximum difference between the successive elements in its sorted form.

Return 0 if the array contains less than 2 elements.

Example 1:

Input: [3,6,9,1]
Output: 3
Explanation: The sorted form of the array is [1,3,6,9], either
             (3,6) or (6,9) has the maximum difference 3.
Example 2:

Input: [10]
Output: 0
Explanation: The array contains less than 2 elements, therefore return 0.
Note:

You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.
Try to solve it in linear time/space.
*/
//Use bucket sort ! the nums with max gap cannot in the same bucket
int maximumGap(vector<int>& nums) {
	if (nums.size() < 2) {
		return 0;
	}
	else if (nums.size() == 2) {
		return abs(nums[0] - nums[1]);
	}
	int size = nums.size();

	int minN = nums[0];
	int maxN = nums[0];

	for (int i = 0; i < size; ++i) {
		minN = min(nums[i], minN);
		maxN = max(nums[i], maxN);
	}

	int gap = (maxN - minN) / size + 1;
	int bucketNum = (maxN - minN) / gap + 1;
	set<int> s;
	vector<int> bucketMin(bucketNum, INT_MAX);
	vector<int> bucketMax(bucketNum, INT_MIN);

	for (int i = 0; i < size; ++i) {
		int ind = (nums[i] - minN) / gap;
		bucketMin[ind] = min(bucketMin[ind], nums[i]);
		bucketMax[ind] = max(bucketMax[ind], nums[i]);
		s.insert(ind);
	}
	int result = 0;
	int pre = 0;
	//Notice start from bucket 1

	for (int i = 1; i < bucketNum; ++i) {
		//empty bucket
		if (!s.count(i)) {
			continue;
		}
		result = max(result, bucketMin[i] - bucketMax[pre]);
		pre = i;
	}
	return result;
	//result = max(0, )
}

/*
# 165. Compare Version Numbers
Compare two version numbers version1 and version2.
If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0.

You may assume that the version strings are non-empty and contain only digits and the . character.
The . character does not represent a decimal point and is used to separate number sequences.
For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.

Example 1:

Input: version1 = "0.1", version2 = "1.1"
Output: -1
Example 2:

Input: version1 = "1.0.1", version2 = "1"
Output: 1
Example 3:

Input: version1 = "7.5.2.4", version2 = "7.5.3"
Output: -1
*/

//Use substr to get nums between two '.'; Notice there might be 0 in front.
//The hard part is to consider 0.0.0...; Method is, when traversal of one string reaches the end, let left = right so that its tail is considered as 0.0.0... until we get result or both string reaches end.
int compareVersion(string version1, string version2) {

	int size1 = version1.size();
	int size2 = version2.size();

	int left1 = 0;
	int right1 = 0;
	int left2 = 0;
	int right2 = 0;

	while (right1 < size1 || right2 < size2) {

		while (right1 < size1 && version1[right1] != '.') {
			++right1;
		}
		while (right2 < size2 && version2[right2] != '.') {
			++right2;
		}

		//when left == right of one string, that means it reaches the end, but still need to consider folloing as 0.0.0... until both reaches the end.
		int i1 = strToInt(version1.substr(left1, right1 - left1));
		int i2 = strToInt(version2.substr(left2, right2 - left2));

		if (i1 > i2) {
			return 1;
		}
		else if (i1 < i2) {
			return -1;
		}
		else {
			if (right1 < size1) {
				++right1;

			}
			//Must let left = right even if it reaches the end so that following is considered as 0.0.0...
			left1 = right1;
			if (right2 < size2) {
				++right2;

			}
			left2 = right2;
		}
	}
	return 0;
}

int strToInt(string str) {
//Consider left = right case as 0.
	if (str == "0" || str.empty()) {
		return 0;
	}

	//Handle 0 in front
	int cur = 0;
	while (cur < str.size() && str[cur] == '0') {
		++cur;
	}

	if (cur == str.size()) {
		return 0;
	}
	else {
		return stoi(str.substr(cur));
	}
}

/*
# 166. Fraction to Recurring Decimal
Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.

If the fractional part is repeating, enclose the repeating part in parentheses.

Example 1:

Input: numerator = 1, denominator = 2
Output: "0.5"
Example 2:

Input: numerator = 2, denominator = 1
Output: "2"
Example 3:

Input: numerator = 2, denominator = 3
Output: "0.(6)"
*/

//Must use long long and labs to get abs and prevent overflow !!! As a result, all related variables have to be long long type.
//Use a map to store all decimal bit and check if we meet the same rem again(rep).
//Notice how to get rem and quo in loop !!! 
string fractionToDecimal(int numerator, int denominator) {

	int sign_num = numerator >= 0 ? 1 : -1;
	int sign_den = denominator >= 0 ? 1 : -1;
	long long numer = labs(numerator);
	long long denom = labs(denominator);

	string result;
	long long quotient = numer / denom;
	long long remainder = numer%denom;

	if (sign_num * sign_den == -1 && !(quotient == 0 && remainder == 0)) {
		result += "-";
	}

	result += to_string(quotient);

	if (remainder == 0) {
		return result;
	}

	string s;
	int pos = 0;
	unordered_map<long long, int> deci;
	result += ".";
	while (remainder != 0) {

		if (deci.count(remainder)) {
			s.insert(s.begin() + deci[remainder], '(');
			s += ")";
			return result + s;
		}

		deci[remainder] = pos;
		++pos;
		s += to_string((remainder * 10) / denom);
		//Notice how to get remainder !!!
		remainder = (remainder * 10) % denom;

	}
	result += s;
	return result;
}

/*
# 167. Two Sum II - Input array is sorted
Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.

Note:

Your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution and you may not use the same element twice.
Example:

Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
*/

//Use two pointers
vector<int> twoSum(vector<int>& numbers, int target) {

	int head = 0;
	int tail = numbers.size() - 1;

	while (head < tail) {
		if (numbers[head] + numbers[tail] > target) {
			--tail;
		}
		else if (numbers[head] + numbers[tail] < target) {
			++head;
		}
		else {
			return { head + 1, tail + 1 };
		}
	}

	return {};
}

/*
# 168. Excel Sheet Column Title
Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
    ...
Example 1:

Input: 1
Output: "A"
Example 2:

Input: 28
Output: "AB"
Example 3:

Input: 701
Output: "ZY"
*/

//Notice always need to minus 1 when calc. Can refer to decimal system (1 - 0, 2 - 1 ... 10 - 9, 11 - 00).
string convertToTitle(int n) {
	string result;

	int quo = (n - 1) / 26;
	int rem = (n - 1) % 26;

	while (quo != 0) {
		result.push_back('A' + rem % 26);
		rem = (quo - 1) % 26;
		quo = (quo - 1) / 26;
	}
	result.push_back('A' + rem % 26);
	reverse(result.begin(), result.end());
	return result;
}

/*
# 169. Majority Element
Given an array of size n, find the majority element. The majority element is the element that appears more than

You may assume that the array is non-empty and the majority element always exist in the array.

Example 1:

Input: [3,2,3]
Output: 3
Example 2:

Input: [2,2,1,1,1,2,2]
Output: 2
*/

//Use a map to count.
int majorityElement(vector<int>& nums) {
	int maj = nums.size() / 2;
	unordered_map<int, int> counts;
	for (int i = 0; i < nums.size(); ++i) {
		if (++counts[nums[i]] > maj) {
			return nums[i];
		}
	}
}

/*
$ 170. Two Sum III - Data structure design
Design and implement a TwoSum class. It should support the following operations:add and find.

add - Add the number to an internal data structure.
find - Find if there exists any pair of numbers which sum is equal to the value.

For example,
add(1); add(3); add(5);
find(4) -> true
find(7) -> false
*/

//Use a map to store the num and its count.
class TwoSum {
public:
    void add(int number) {
        ++m[number];
    }
    bool find(int value) {
        for (auto a : m) {
            int t = value - a.first;
            if ((t != a.first && m.count(t)) || (t == a.first && a.second > 1)) {
                return true;
            }
        }
        return false;
    }
private:
    unordered_map<int, int> m;
};

/*
# 171. Excel Sheet Column Number
Given a column title as appear in an Excel sheet, return its corresponding column number.

For example:

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
Example 1:

Input: "A"
Output: 1
Example 2:

Input: "AB"
Output: 28
Example 3:

Input: "ZY"
Output: 701
*/

//Reverse the s and accumulate. Notice how to do pow(26, i)
int titleToNumber(string s) {

	int res = 0;
	int pow = 1;
	reverse(s.begin(), s.end());
	for (int i = 0; i < s.size(); ++i) {
		res += (s[i] - 'A' + 1) * pow;
		pow *= 26;
	}
	return res;
}

/*
# 172. Factorial Trailing Zeroes
Given an integer n, return the number of trailing zeroes in n!.

Example 1:

Input: 3
Output: 0
Explanation: 3! = 6, no trailing zero.
Example 2:

Input: 5
Output: 1
Explanation: 5! = 120, one trailing zero.
Note: Your solution should be in logarithmic time complexity.
*/

//Notice nums like 25 can be represented as 5x5, that means 25! has six '5'. So need to find how many 5, not just n/5
int trailingZeroes(int n) {
	int res = 0;

	while (n != 0) {
		res += n / 5;
		n /= 5;
	}
	return res;
}

/*
# 173. Binary Search Tree Iterator
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.
BSTIterator iterator = new BSTIterator(root);
iterator.next();    // return 3
iterator.next();    // return 7
iterator.hasNext(); // return true
iterator.next();    // return 9
iterator.hasNext(); // return true
iterator.next();    // return 15
iterator.hasNext(); // return true
iterator.next();    // return 20
iterator.hasNext(); // return false
 

Note:

next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.
*/
/**
* Definition for a binary tree node.
* struct TreeNode {
*     int val;
*     TreeNode *left;
*     TreeNode *right;
*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
* };
*/

//Use stack to alwasys store most left nodes. If a node is pop and has a right branches, then push most left nodes of the right branches.
class BSTIterator {
public:
	BSTIterator(TreeNode* root) {
		while (root) {
			nodes.push(root);
			root = root->left;
		}
	}

	/** @return the next smallest number */
	int next() {
		TreeNode* cur = nodes.top();
		nodes.pop();
		int smallest = cur->val;
		if (cur->right) {
			cur = cur->right;
			while (cur) {
				nodes.push(cur);
				cur = cur->left;
			}
		}
		return smallest;
	}

	/** @return whether we have a next smallest number */
	bool hasNext() {
		if (nodes.empty()) {
			return false;
		}
		else {
			return true;
		}
	}
private:
	stack<TreeNode*> nodes;
};

/**
* Your BSTIterator object will be instantiated and called as such:
* BSTIterator* obj = new BSTIterator(root);
* int param_1 = obj->next();
* bool param_2 = obj->hasNext();
*/

/*
# 174. Dungeon Game
The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.

The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.

Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).

In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.

 

Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.

For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-> RIGHT -> DOWN -> DOWN.

Note:

The knight's health has no upper bound.
Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.
*/

//Traverse from the end to start. dp[i][j] represents the least HP needed when start at (i, j). Notice the initial hp is at least 1.
//iniHP[i][j] = max(1, min(iniHP[i + 1][j], iniHP[i][j + 1]) - dungeon[i][j]);
int calculateMinimumHP(vector<vector<int>>& dungeon) {
	int m = dungeon.size();
	int n = dungeon[0].size();
	vector<vector<int>> iniHP(m, vector<int>(n, 1));

	iniHP[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1]);
	for (int i = m - 2; i >= 0; --i) {
		iniHP[i][n - 1] = max(1, iniHP[i + 1][n - 1] - dungeon[i][n - 1]);
	}
	for (int i = n - 2; i >= 0; --i) {
		iniHP[m - 1][i] = max(1, iniHP[m - 1][i + 1] - dungeon[m - 1][i]);
	}

	for (int i = m - 2; i >= 0; --i) {
		for (int j = n - 2; j >= 0; --j) {
			iniHP[i][j] = max(1, min(iniHP[i + 1][j], iniHP[i][j + 1]) - dungeon[i][j]);
		}
	}

	return iniHP[0][0];
}

/*
# 175. Combine Two Tables
Table: Person

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId is the primary key column for this table.
Table: Address

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId is the primary key column for this table.
 

Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:

FirstName, LastName, City, State
*/

//Using join.
//Method1: use USING() 
SELECT Person.FirstName, Person.LastName, Address.city, Address.State FROM Person LEFT JOIN Address USING(PersonID);
//Method2: use ON
SELECT Person.FirstName, Person.LastName, Address.City, Address.State FROM Person LEFT JOIN Address ON Person.PersonId = Address.PersonId;
//Method3: use NATURAL
SELECT Person.FirstName, Person.LastName, Address.City, Address.State FROM Person NATURAL LEFT JOIN Address;

/*
# 176. Second Highest Salary
Write a SQL query to get the second highest salary from the Employee table.

+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
For example, given the above Employee table, the query should return 200 as the second highest salary. If there is no second highest salary, then the query should return null.

+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
*/
//Notice max() will return null when no result. Notice how to use distinct to remove dup. limit 1,1 means show only one record and offset 1.
//(select distinct(Salary) from Employee order by Salary desc limit 1,1) returns exact the second highest salary.
Select max(Salary) as SecondHighestSalary from Employee where Salary =(select distinct(Salary) from Employee order by Salary desc limit 1,1);

/*
# 177. Nth Highest Salary
Write a SQL query to get the nth highest salary from the Employee table.

+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null.

+------------------------+
| getNthHighestSalary(2) |
+------------------------+
| 200                    |
+------------------------+
*/
//Notice to SET N=N-1; Notice the usage of limit m,n. offset m and return the first n records.
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
SET N=N-1;
  RETURN (
      # Write your MySQL query statement below.
      Select max(Salary) from Employee where Salary =(select distinct(Salary) from Employee order by Salary desc limit N, 1)
  );
END

/*
# 178. Rank Scores
Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no "holes" between ranks.

+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
For example, given the above Scores table, your query should generate the following report (order by highest score):

+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
*/
//Use count to calc rank. Notice to use distinct for no holes version.
select Score, (select count(distinct(Score)) from Scores c where c.Score >= s.Score) Rank from Scores s order by Score desc;

//holes version
/*select Score, (select count(Score)+1 from Scores c where c.Score > s.Score) Rank from Scores s order by Score desc;*/

/*
# 179. Largest Number
Given a list of non negative integers, arrange them such that they form the largest number.

Example 1:

Input: [10,2]
Output: "210"
Example 2:

Input: [3,30,34,5,9]
Output: "9534330"
Note: The result may be very large, so you need to return a string instead of an integer.
*/

//Notice how to sort the inputs:return to_string(a) + to_string(b) > to_string(b) + to_string(a)
//Notice to erase 0 in front before return
string largestNumber(vector<int>& nums) {

	if (nums.empty()) {
		return 0;
	}
	else if (nums.size() == 1) {
		return to_string(nums[0]);
	}

	sort(nums.begin(), nums.end(), [](int a, int b) { return to_string(a) + to_string(b) > to_string(b) + to_string(a);});

	string result;
	for (int i = 0; i < nums.size(); ++i) {
		result += to_string(nums[i]);
	}

	//Erase 0 in front
	int i = 0;
	while (i < result.size() - 1 && result[i] == '0') {
		result.erase(result.begin());
	}

	return result;
}

/*
# 180. Consecutive Numbers
Write a SQL query to find all numbers that appear at least three times consecutively.

+----+-----+
| Id | Num |
+----+-----+
| 1  |  1  |
| 2  |  1  |
| 3  |  1  |
| 4  |  2  |
| 5  |  1  |
| 6  |  2  |
| 7  |  2  |
+----+-----+
For example, given the above Logs table, 1 is the only number that appears consecutively for at least three times.

+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
*/
//Notice how to use join on. distinct is necessary
select distinct l1.Num as ConsecutiveNums from Logs l1 join Logs l2 on l1.Id = l2.Id - 1 join Logs l3 on l1.Id = l3.Id - 2 where l1.Num = l2.Num And l2.Num = l3.Num;

/*
# 181. Employees Earning More Than Their Managers
The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.

+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+
Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.

+----------+
| Employee |
+----------+
| Joe      |
+----------+
*/
//Use join on and where
select e.Name as Employee from Employee e join Employee m on e.ManagerId = m.Id where e.Salary > m.Salary;

/*
# 182. Duplicate Emails
Write a SQL query to find all duplicate emails in a table named Person.

+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
For example, your query should return the following for the above table:

+---------+
| Email   |
+---------+
| a@b.com |
+---------+
Note: All emails are in lowercase.
*/
//Use join on or group by .. having count(*) ...
//join
select distinct a.Email from Person a join Person b on a.Email = b.Email and a.Id != b.Id;
//group by .. having count(*) ...
SELECT DISTINCT p1.Email FROM Person p1
JOIN Person p2 ON p1.Email = p2.Email
WHERE p1.Id <> p2.Id;

/*
# 183. Customers Who Never Order
Suppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything.

Table: Customers.

+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
Table: Orders.

+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
Using the above tables as example, return the following:

+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
*/
//Use not in
select Name as Customers from Customers c where c.Id not in (select CustomerId from Orders);

/*
# 184. Department Highest Salary
The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.

+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
+----+-------+--------+--------------+
The Department table holds all departments of the company.

+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department.

+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+
*/

//Use join on to connect two tables and order by departmentId and salary; Use where to limit how many records (count < n) and department (id1 = id2) to show.   
select d.Name as Department, e.Name as Employee, e.Salary from Employee e join Department d on e.DepartmentId = d.Id where (select count(distinct(Salary)) from Employee where DepartmentId = e.DepartmentId and Salary > e.Salary) < 1 order by e.DepartmentId, e.Salary desc;

/*
# 185. Department Top Three Salaries
The Employee table holds all employees. Every employee has an Id, and there is also a column for the department Id.

+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
| 5  | Janet | 69000  | 1            |
| 6  | Randy | 85000  | 1            |
+----+-------+--------+--------------+
The Department table holds all departments of the company.

+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows.

+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| IT         | Randy    | 85000  |
| IT         | Joe      | 70000  |
| Sales      | Henry    | 80000  |
| Sales      | Sam      | 60000  |
+------------+----------+--------+
*/
//Use join on to connect two tables and order by departmentId and salary; Use where to limit how many records (count < n) and department (id1 = id2) to show.   
select d.Name as Department, e.Name as Employee, e.Salary from Employee e join Department d on e.DepartmentId = d.Id where (select count(distinct(Salary)) from Employee where DepartmentId = e.DepartmentId and Salary > e.Salary) < 3 order by e.DepartmentId, e.Salary desc;

/*
# 186 Reverse Words in a String II
Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.
The input string does not contain leading or trailing spaces and the words are always separated by a single space.
For example,
Given s = "the sky is blue",
return "blue is sky the".
Could you do it in-place without allocating extra space?
*/
//Almost the same as #151 and don't need to handle dup spaces in head and tail
class Solution {
public:
    void reverseWords(string &s) {
        int left = 0;
        for (int i = 0; i <= s.size(); ++i) {
            if (i == s.size() || s[i] == ' ') {
                reverse(s, left, i - 1);
                left = i + 1;
            }
        }
        reverse(s, 0, s.size() - 1);
    }
    void reverse(string &s, int left, int right) {
        while (left < right) {
            char t = s[left];
            s[left] = s[right];
            s[right] = t;
            ++left; --right;
        }
    }
};

/*
# 187. Repeated DNA Sequences
All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.

Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.

Example:

Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"

Output: ["AAAAACCCCC", "CCCCCAAAAA"]
*/

//Method1: use hashMap to force traversal.
vector<string> findRepeatedDnaSequences(string s) {
	if (s.size() < 11) {
		return {};
	}
	vector<string> result;
	int SIZE = 10;
	unordered_map<string, int> repeats;
	for (int i = 0; i <= s.size() - 10; ++i) {
		string cur = s.substr(i, SIZE);
		++repeats[cur];
	}

	for (auto s : repeats) {
		if (s.second >= 2) {
			result.push_back(s.first);
		}
	}

	return result;
}
//Method2: bit manipulation
//Method3: rolling-hash

/*
# 188. Best Time to Buy and Sell Stock IV
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

Example 1:

Input: [2,4,1], k = 2
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.
Example 2:

Input: [3,2,6,5,0,3], k = 2
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.
             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
*/
//Use dp.
//maxPro[i][j] has two cases:1. kth transaction was done in pasted j-1 days. 2. do the kth transaction(sell) on jth day. Where the second case is 
//prices[j] - tmp means prices[j] - prices[m] + maxPro[i - 1][m - 1]. That is sell the stocks bought on mth day, we need to find the maxPro that use i-1 transactions before mth day.
int maxProfit(int k, vector<int>& prices) {
	if (prices.size() <= 1 || k <= 0) {
		return 0;
	}
	else if (k > prices.size()) {
		//if k is greater than days, that is equals to unlimited transaction case.
		return unlimitTrans(prices);
	}

	vector<vector<int>> maxPro(k, vector<int>(prices.size(), 0));
	maxPro[0][0] = 0;
	//Initial k=1 cases
	for (int i = 1; i < prices.size(); ++i) {
		int lowest = prices[0];
		//Notice j <= i here
		for (int j = 0; j <= i; ++j) {
			lowest = min(lowest, prices[j]);
			maxPro[0][i] = max(prices[j] - lowest, maxPro[0][i - 1]);
		}
	}

	for (int i = 1; i < k; ++i) {
		for (int j = 1; j < prices.size(); ++j) {
			int tmp = INT_MAX;
			for (int m = 0; m < j; ++m) {
				tmp = min(tmp, prices[m] - maxPro[i - 1][m - 1]);
			}
			//maxPro[i][j] has two cases:1. kth transaction was done in pasted j-1 days. 
			//2. do the kth transaction(sell) on jth day. Where the second case is 
			//prices[j] - tmp means prices[j] - prices[m] + maxPro[i - 1][m - 1]
			//That is sell the stocks bought on mth day, we need to find the maxPro 
			//that use i-1 transactions before mth day.
			maxPro[i][j] = max(maxPro[i][j - 1], prices[j] - tmp);
		}
	}

	return maxPro[k - 1][prices.size() - 1];
}

int unlimitTrans(vector<int> prices) {
	int result = 0;
	for (int i = 0; i < prices.size() - 1; ++i) {
		if (prices[i] < prices[i + 1]) {
			result += prices[i + 1] - prices[i];
		}
	}
	return result;
}

/*
# 189. Rotate Array
Given an array, rotate the array to the right by k steps, where k is non-negative.

Example 1:

Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
Example 2:

Input: [-1,-100,3,99] and k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
Note:

Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
Could you do it in-place with O(1) extra space?
*/
//Method1: move tail element to beginning.
void rotate(vector<int>& nums, int k) {

	int steps = k%nums.size();
	for (int i = 0; i < steps; ++i) {
		//int cur = nums.back();
		nums.insert(nums.begin(), nums.back());
		nums.pop_back();
	}
}

//Method2: reverse the first n-k elements. then reverse last k elements. then reverse the whole array
//Method3: copy a new array. take use of mapping i -> (i+k)%n to modify nums.

/*
# 190. Reverse Bits
Reverse bits of a given 32 bits unsigned integer.

 

Example 1:

Input: 00000010100101000001111010011100
Output: 00111001011110000010100101000000
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.
Example 2:

Input: 11111111111111111111111111111101
Output: 10111111111111111111111111111111
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001.
 

Note:

Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825.
*/
//use & 1 to check if the tail bit is 1 or 0 and then copy the bit to the tail of result. For 1, << 1 and then ++, for 0, just <<.
uint32_t reverseBits(uint32_t n) {
	uint32_t result = 0;
	for (int i = 0; i < 32; ++i) {
		if (n & 1 == 1) {
			result = result << 1;
			++result;
		}
		else {
			result = result << 1;
		}

		n = n >> 1;
	}
	return result;
}

/*
# 191. Number of 1 Bits
Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the Hamming weight).

 

Example 1:

Input: 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
Example 2:

Input: 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
Example 3:

Input: 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
 

Note:

Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3 above the input represents the signed integer -3.
*/
//right move and count.
int hammingWeight(uint32_t n) {
	int count = 0;
	for (int i = 0; i < 32; ++i) {
		if (n & 1 == 1) {
			++count;
		}
		n = n >> 1;
	}
	return count;
}

/*
# 192. Word Frequency
Write a bash script to calculate the frequency of each word in a text file words.txt.

For simplicity sake, you may assume:

words.txt contains only lowercase characters and space ' ' characters.
Each word must consist of lowercase characters only.
Words are separated by one or more whitespace characters.
Example:

Assume that words.txt has the following content:

the day is sunny the the
the sunny is is
Your script should output the following, sorted by descending frequency:

the 4
is 3
sunny 2
day 1
Note:

Don't worry about handling ties, it is guaranteed that each word's frequency count is unique.
Could you write it in one-line using Unix pipes?
*/
//Notice uniq only filter adjacent dup lines so need a sort infront.
grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -nr | awk '{print $2" "$1}'

/*
# 193. Valid Phone Numbers
Given a text file file.txt that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.

You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)

You may also assume each line in the text file must not contain leading or trailing white spaces.

Example:

Assume that file.txt has the following content:

987-123-4567
123 456 7890
(123) 456-7890
Your script should output the following valid phone numbers:

987-123-4567
(123) 456-7890
*/
//regular expression
awk '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/' file.txt

/*
# 194. Transpose File
Given a text file file.txt, transpose its content.

You may assume that each row has the same number of columns and each field is separated by the ' ' character.

Example:

If file.txt has the following content:

name age
alice 21
ryan 30
Output the following:

name alice ryan
age 21 30
*/
//Notice the codes run for each row !. NF represents how many cols. NR represents cur row num. 
awk '{
    for(i = 1; i <= NF; ++i){
        if(NR == 1) s[i] = $i;
        else s[i] = s[i] " " $i;
    }
} END {
    for(i = 1; s[i] != ""; ++i){
        print s[i];
    }
}' file.txt

/*
# 195. Tenth Line
Given a text file file.txt, print just the 10th line of the file.

Example:

Assume that file.txt has the following content:

Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
Your script should output the tenth line, which is:

Line 10
Note:
1. If the file contains less than 10 lines, what should you output?
2. There's at least three different solutions. Try to explore all possibilities.
*/
//method1: use awk NR
awk '{if(NR==10) print $0}' file.txt
//method2: use head tail

/*
# 196. Delete Duplicate Emails
Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.

+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id is the primary key column for this table.
For example, after running your query, the above Person table should have the following rows:

+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
Note:

Your output is the whole Person table after executing your sql. Use delete statement.
*/
//Use where or use join.
delete p1 from Person p1, Person p2 where p1.Email = p2.Email and p1.Id > p2.Id;

/*
# 197. Rising Temperature
Given a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.

+---------+------------------+------------------+
| Id(INT) | RecordDate(DATE) | Temperature(INT) |
+---------+------------------+------------------+
|       1 |       2015-01-01 |               10 |
|       2 |       2015-01-02 |               25 |
|       3 |       2015-01-03 |               20 |
|       4 |       2015-01-04 |               30 |
+---------+------------------+------------------+
For example, return the following Ids for the above Weather table:

+----+
| Id |
+----+
|  2 |
|  4 |
+----+
*/
//Notice how to use datediff
select w1.Id from Weather w1, Weather w2 where w1.Temperature > w2.Temperature and datediff(w1.RecordDate, w2.RecordDate) = 1;

/*
# 198. House Robber
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
Example 2:

Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.
*/
//Use dp. total[i] means the max amount of money can get if you rob ith house. It is the nums[i] plus max of total[i - 2] and total[i - 3] because you cannot robber adjacent house
int rob(vector<int>& nums) {
	if (nums.empty()) {
		return 0;
	}
	else if (nums.size() == 1) {
		return nums[0];
	}
	vector<int> total(nums.size(), 0);
	total[0] = nums[0];
	total[1] = nums[1];
	total[2] = nums[2] + nums[0];

	for (int i = 3; i < nums.size(); ++i) {
		total[i] = nums[i] + max(total[i - 2], total[i - 3]);
	}

	return max(total[nums.size() - 1], total[nums.size() - 2]);
}

/*
# 199. Binary Tree Right Side View
Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

Example:

Input: [1,2,3,null,5,null,4]
Output: [1, 3, 4]
Explanation:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---
*/
//Use level traversal and save the last node val of each level
vector<int> rightSideView(TreeNode* root) {
	if (!root) {
		return {};
	}

	queue<TreeNode*> nodes;
	nodes.push(root);
	vector<int> result;
	while (!nodes.empty()) {
		int size = nodes.size();
		for (int i = 0; i < size; ++i) {
			TreeNode* curNode = nodes.front();
			nodes.pop();
			if (curNode->left) {
				nodes.push(curNode->left);
			}
			if (curNode->right) {
				nodes.push(curNode->right);
			}
			if (i == size - 1) {
				result.push_back(curNode->val);
			}
		}
	}

	return result;
}

/*
# 200. Number of Islands
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:

Input:
11110
11010
11000
00000

Output: 1
Example 2:

Input:
11000
11000
00100
00011

Output: 3
*/

//Use dfs. Notice must use pass by ref when using deep DFS to save time and memory.
//Use a visit grid to record if any land is visted. When visit a new land, it is a new island and then visit its adjacent lands.
int numIslands(vector<vector<char>>& grid) {
	if (grid.empty() || grid[0].empty()) return 0;

	int m = grid.size(), n = grid[0].size(), result = 0;
	vector<vector<bool>> visited(m, vector<bool>(n, false));
	for (int i = 0; i < m; ++i) {
		for (int j = 0; j < n; ++j) {
			if (grid[i][j] == '1' && !visited[i][j]) {
				explore(visited, i, j, grid);
				++result;
			}
		}
	}
	return result;
}

void explore(vector<vector<bool>>& vis, int row, int col, vector<vector<char>>& grid) {
	//Notice border
	if (row < 0 || row >= grid.size()) return;
	if (col < 0 || col >= grid[0].size()) return;
	if (grid[row][col] != '1' || vis[row][col]) return;
	vis[row][col] = true;
	explore(vis, row - 1, col, grid);
	explore(vis, row + 1, col, grid);
	explore(vis, row, col - 1, grid);
	explore(vis, row, col + 1, grid);
}